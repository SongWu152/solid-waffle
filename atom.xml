<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小莫的博客-fighting(技术分享、生活随笔)</title>
  
  <subtitle>行百里者半九十</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaomo.info/"/>
  <updated>2019-10-08T14:43:43.652Z</updated>
  <id>https://xiaomo.info/</id>
  
  <author>
    <name>小莫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jdk源码系列-Java到底是值传递还是引用传递？</title>
    <link href="https://xiaomo.info/2019/javaPassByValueAndReference/"/>
    <id>https://xiaomo.info/2019/javaPassByValueAndReference/</id>
    <published>2019-08-05T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.652Z</updated>
    
    <content type="html"><![CDATA[<p>首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用的准确含义吧？可是如果你已经知道了这两个名字的准确含义，那么你自己就能判断Java到底是传值还是传引用。这就好像用大学的名词来解释高中的题目，对于初学者根本没有任何意义。<br><a id="more"></a></p><h1 id="一、搞清楚-基本类型-和-引用类型的不同之处"><a href="#一、搞清楚-基本类型-和-引用类型的不同之处" class="headerlink" title="一、搞清楚 基本类型 和 引用类型的不同之处"></a>一、搞清楚 基本类型 和 引用类型的不同之处</h1><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int num</span> = 10;</span><br><span class="line"><span class="attribute">String str</span> = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/166032bc90958c21604110441ad03f45_hd.jpg" alt></p><p>如图所示，num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为”引用”，引用指向实际对象，实际对象中保存着内容。</p><h1 id="二、搞清楚赋值运算符（-）的作用"><a href="#二、搞清楚赋值运算符（-）的作用" class="headerlink" title="二、搞清楚赋值运算符（=）的作用"></a>二、搞清楚赋值运算符（=）的作用</h1><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int num</span> = 10;</span><br><span class="line"><span class="attribute">String str</span> = <span class="string">"hello"</span>;</span><br><span class="line"><span class="attribute">num</span> = 20;</span><br><span class="line"><span class="attribute">str</span> = <span class="string">"java"</span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/287c0efbb179638cf4cf27cbfdf3e746_hd.jpg" alt></p><p>对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。<code>但是原来的对象不会被改变（重要）。</code> 如上图所示，”hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）</p><h1 id="三、调用方法时发生了什么？参数传递基本上就是赋值操作。"><a href="#三、调用方法时发生了什么？参数传递基本上就是赋值操作。" class="headerlink" title="三、调用方法时发生了什么？参数传递基本上就是赋值操作。"></a>三、调用方法时发生了什么？参数传递基本上就是赋值操作。</h1><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">第一个例子：基本类型</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">value</span> = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(num); <span class="comment">// num 没有被改变</span></span><br></pre></td></tr></table></figure><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">第二个例子：没有提供改变自身方法的引用类型</span><br><span class="line"><span class="keyword">void</span> foo(<span class="keyword">String</span> <span class="built_in">text</span>) &#123;</span><br><span class="line">    <span class="built_in">text</span> = <span class="string">"windows"</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="built_in">str</span>); <span class="comment">// str 也没有被改变</span></span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">第三个例子：提供了改变自身方法的引用类型</span><br><span class="line"><span class="keyword">StringBuilder </span><span class="built_in">sb</span> = new <span class="keyword">StringBuilder("iphone");</span></span><br><span class="line"><span class="keyword">void </span>foo(<span class="keyword">StringBuilder </span><span class="keyword">builder) </span>&#123;</span><br><span class="line">    <span class="keyword">builder.append("4");</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword">foo(sb); </span>// <span class="built_in">sb</span> 被改变了，变成了<span class="string">"iphone4"</span>。</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。</span><br><span class="line"><span class="keyword">StringBuilder </span><span class="built_in">sb</span> = new <span class="keyword">StringBuilder("iphone");</span></span><br><span class="line"><span class="keyword">void </span>foo(<span class="keyword">StringBuilder </span><span class="keyword">builder) </span>&#123;</span><br><span class="line">    <span class="keyword">builder </span>= new <span class="keyword">StringBuilder("ipad");</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword">foo(sb); </span>// <span class="built_in">sb</span> 没有被改变，还是 <span class="string">"iphone"</span>。</span><br></pre></td></tr></table></figure><p>重点理解为什么，第三个例子和第四个例子结果不同？</p><p>下面是第三个例子的图解：<br><img src="https://pic2.zhimg.com/80/d8b82e07ea21375ca6b300f9162aa95f_hd.jpg" alt><br><code>builder.append(&quot;4&quot;)之后</code><br><img src="https://pic2.zhimg.com/80/ff2ede9c6c55568d42425561f25a0fd7_hd.jpg" alt></p><p>下面是第四个例子的图解：<br><img src="https://pic2.zhimg.com/80/d8b82e07ea21375ca6b300f9162aa95f_hd.jpg" alt><br><code>builder = new StringBuilder(&quot;ipad&quot;);</code> 之后<br><img src="https://pic4.zhimg.com/80/46fa5f10cc135a3ca087dae35a5211bd_hd.jpg" alt></p><h1 id="从局部变量-方法参数开始讲起"><a href="#从局部变量-方法参数开始讲起" class="headerlink" title="从局部变量/方法参数开始讲起"></a>从局部变量/方法参数开始讲起</h1><p>局部变量和方法参数在jvm中的储存方法是相同的，都是在栈上开辟空间来储存的，随着进入方法开辟，退出方法回收。以32位JVM为例，boolean/byte/short/char/int/float以及引用都是分配4字节空间，long/double分配8字节空间。对于每个方法来说，最多占用多少空间是一定的，这在编译时就可以计算好。</p><p>我们都知道JVM内存模型中有，stack和heap的存在，但是更准确的说，是每个线程都分配一个独享的stack，所有线程共享一个heap。对于每个方法的局部变量来说，是绝对无法被其他方法，甚至其他线程的同一方法所访问到的，更遑论修改。当我们在方法中声明一个 int i = 0，或者 Object obj = null 时，仅仅涉及stack，不影响到heap，当我们 new Object() 时，会在heap中开辟一段内存并初始化Object对象。</p><p>当我们将这个对象赋予obj变量时，仅仅是stack中代表obj的那4个字节变更为这个对象的地址。</p><h1 id="数组类型引用和对象："><a href="#数组类型引用和对象：" class="headerlink" title="数组类型引用和对象："></a>数组类型引用和对象：</h1><p>当我们声明一个数组时，如int[] arr = new int[10]，因为数组也是对象，arr实际上是引用，stack上仅仅占用4字节空间，new int[10]会在heap中开辟一个数组对象，然后arr指向它。</p><p>当我们声明一个二维数组时，如 int[][] arr2 = new int[2][4]，arr2同样仅在stack中占用4个字节，会在内存中开辟一个长度为2的，类型为int[]的数组，然后arr2指向这个数组。这个数组内部有两个引用（大小为4字节），分别指向两个长度为4的类型为int的数组。</p><p><img src="https://pic4.zhimg.com/80/v2-6590cb935ae8bf3b7241cb309fe041d7_hd.jpg" alt></p><p>所以当我们传递一个数组引用给一个方法时，数组的元素是可以被改变的，但是无法让数组引用指向新的数组。</p><p>你还可以这样声明：int[][] arr3 = new int[3][]，这时内存情况如下图</p><p><img src="https://pic2.zhimg.com/80/v2-fdc86227021d56a02b559d6485983c71_hd.jpg" alt></p><p>你还可以这样 arr3[0] = new int [5]; arr3[1] = arr2[0];</p><p><img src="https://pic1.zhimg.com/80/v2-fdc5e737a95d625a47d66ab61e4a2f55_hd.jpg" alt></p><h1 id="关于String"><a href="#关于String" class="headerlink" title="关于String"></a>关于String</h1><p>String对象内部仅需要维护三个变量，char[] chars, int startIndex, int length。而chars在某些情况下是可以共用的。但是因为String被设计成为了不可变类型，所以你思考时把String对象简化考虑也是可以的。String str = new String(“hello”)</p><p><img src="https://pic4.zhimg.com/80/v2-a143d0a3594d06f54c6853c46c429e08_hd.jpg" alt></p><p>当然某些JVM实现会把”hello”字面量生成的String对象放到常量池中，而常量池中的对象可以实际分配在heap中，有些实现也许会分配在方法区，当然这对我们理解影响不大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用的准确含义吧？可是如果你已经知道了这两个名字的准确含义，那么你自己就能判断Java到底是传值还是传引用。这就好像用大学的名词来解释高中的题目，对于初学者根本没有任何意义。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-Thread.sleep(0)和Thread.sleep(1)的区别</title>
    <link href="https://xiaomo.info/2019/jdkSourceCodeReadThreadSleep/"/>
    <id>https://xiaomo.info/2019/jdkSourceCodeReadThreadSleep/</id>
    <published>2019-07-22T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？Thread.Sleep(0) 表示挂起0毫秒，你可能觉得没作用，你要写Thread.Sleep(1000) 就有感觉了。<br><a id="more"></a></p><p>Thread.Sleep(0) 并非是真的要线程挂起0毫秒，意义在于这次调用Thread.Sleep(0)的当前线程确实的被冻结了一下，让其他线程有机会优先执行。Thread.Sleep(0) 是你的线程暂时放弃cpu，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个让位动作。<br>在线程中，调用sleep（0）可以释放cpu时间，让线程马上重新回到就绪队列而非等待队列，sleep(0)释放当前线程所剩余的时间片（如果有剩余的话），这样可以让操作系统切换其他线程来执行，提升效率。<br>我们可能经常会用到 Thread.Sleep 函数来使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？</p><h1 id="回顾一下操作系统原理"><a href="#回顾一下操作系统原理" class="headerlink" title="回顾一下操作系统原理"></a>回顾一下操作系统原理</h1><p>操作系统中，CPU竞争有很多种策略。Unix系统使用的是时间片算法，而Windows则属于抢占式的。<br>在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在 时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程 序所要做的就是维护一张就绪进程列表，，当进程用完它的时间片后，它被移到队列的末尾。</p><p>所谓抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢 占式操作系统中，操作系统假设所有的进程都是“人品很好”的，会主动退出 CPU 。在抢占式操作系统中，假设有若干进程，操作系统会根据他们的优先级、饥饿时间（已经多长时间没有使用过 CPU 了），给他们算出一 个总的优先级来。操作系统就会把 CPU 交给总优先级最高的这个进程。当进程执行完毕或者自己主动挂起后，操作系统就会重新计算一 次所有进程的总优先级，然后再挑一个优先级最高的把 CPU 控制权交给他。</p><p>我们用分蛋糕的场景来描述这两种算法。假设有源源不断的蛋糕（源源不断的时间），一副刀叉（一个CPU），10个等待吃蛋糕的人（10 个进程）。<br>如果是 Unix操作系统来负责分蛋糕，那么他会这样定规矩：每个人上来吃 1 分钟，时间到了换下一个。最后一个人吃完了就再从头开始。于是，不管这10个人是不是优先级不同、饥饿程度不同、饭量不同，每个人上来的时候都可以吃 1 分钟。当然，如果有人本来不太饿，或者饭量小，吃了30秒钟之后就吃饱了，那么他可以跟操作系统说：我已经吃饱了（挂起）。于是操作系统就会让下一个人接着来。<br>如果是 Windows 操作系统来负责分蛋糕的，那么场面就很有意思了。他会这样定规矩：我会根据你们的优先级、饥饿程度去给你们每个人计算一个优先级。优先级最高的那个人，可以上来吃蛋糕——吃到你不想吃为止。等这个人吃完了，我再重新根据优先级、饥饿程度来计算每个人的优先级，然后再分给优先级最高的那个人。<br>这样看来，这个场面就有意思了——可能有些人是PPMM，因此具有高优先级，于是她就可以经常来吃蛋糕。可能另外一个人是个丑男，而去很ws，所以优先级特别低，于是好半天了才轮到他一次（因为随着时间的推移，他会越来越饥饿，因此算出来的总优先级就会越来越高，因此总有一天会轮到他的）。而且，如果一不小心让一个大胖子得到了刀叉，因为他饭量大，可能他会霸占着蛋糕连续吃很久很久，导致旁边的人在那里咽口水。。。</p><p>而且，还可能会有这种情况出现：操作系统现在计算出来的结果，5号PPMM总优先级最高，而且高出别人一大截。因此就叫5号来吃蛋糕。5号吃了一小会儿，觉得没那么饿了，于是说“我不吃了”（挂起）。因此操作系统就会重新计算所有人的优先级。因为5号刚刚吃过，因此她的饥饿程度变小了，于是总优先级变小了；而其他人因为多等了一会儿，饥饿程度都变大了，所以总优先级也变大了。不过这时候仍然有可能5号的优先级比别的都高，只不过现在只比其他的高一点点——但她仍然是总优先级最高的啊。因此操作系统就会说：5号mm上来吃蛋糕……（5号mm心里郁闷，这不刚吃过嘛……人家要减肥……谁叫你长那么漂亮，获得了那么高的优先级）。</p><p>那么，Thread.Sleep 函数是干吗的呢？还用刚才的分蛋糕的场景来描述。上面的场景里面，5号MM在吃了一次蛋糕之后，觉得已经有8分饱了，她觉得在未来的半个小时之内都不想再来吃蛋糕了，那么她就会跟操作系统说：在未来的半个小时之内不要再叫我上来吃蛋糕了。这样，操作系统在随后的半个小时里面重新计算所有人总优先级的时候，就会忽略5号mm。Sleep函数就是干这事的，他告诉操作系统“在未来的多少毫秒内我不参与CPU竞争”。</p><p>看完了 Thread.Sleep 的作用，我们再来想想文章开头的两个问题。<br>对于第一个问题，答案是：不一定。因为你只是告诉操作系统：在未来的1000毫秒内我不想再参与到CPU竞争。那么1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束；况且，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。与此相似的，Thread有个Resume函数，是用来唤醒挂起的线程的。好像上面所说的一样，这个函数只是“告诉操作系统我从现在起开始参与CPU竞争了”，这个函数的调用并不能马上使得这个线程获得CPU控制权。</p><p>对于第二个问题，答案是：有，而且区别很明显。假设我们刚才的分蛋糕场景里面，有另外一个PPMM 7号，她的优先级也非常非常高（因为非常非常漂亮），所以操作系统总是会叫道她来吃蛋糕。而且，7号也非常喜欢吃蛋糕，而且饭量也很大。不过，7号人品很好，她很善良，她没吃几口就会想：如果现在有别人比我更需要吃蛋糕，那么我就让给他。因此，她可以每吃几口就跟操作系统说：我们来重新计算一下所有人的总优先级吧。不过，操作系统不接受这个建议——因为操作系统不提供这个接口。于是7号mm就换了个说法：“在未来的0毫秒之内不要再叫我上来吃蛋糕了”。这个指令操作系统是接受的，于是此时操作系统就会重新计算大家的总优先级——注意这个时候是连7号一起计算的，因为“0毫秒已经过去了”嘛。因此如果没有比7号更需要吃蛋糕的人出现，那么下一次7号还是会被叫上来吃蛋糕。<br>因此，Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。</p><p>末了说明一下，虽然上面提到说“除非它自己放弃使用 CPU ，否则将完全霸占 CPU”，但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。至于我们的大循环造成程序假死，并不是因为这个线程一直在霸占着CPU。实际上在这段时间操作系统已经进行过多次CPU竞争了，只不过其他线程在获得CPU控制权之后很短时间内马上就退出了，于是就又轮到了这个线程继续执行循环，于是就又用了很久才被操作系统强制挂起。。。因此反应到界面上，看起来就好像这个线程一直在霸占着CPU一样。<br>末了再说明一下，文中线程、进程有点混乱，其实在Windows原理层面，CPU竞争都是线程级的，本文中把这里的进程、线程看成同一个东西就好了。</p><h1 id="问题：主动的放弃运行让系统调度的意义是什么呢？"><a href="#问题：主动的放弃运行让系统调度的意义是什么呢？" class="headerlink" title="问题：主动的放弃运行让系统调度的意义是什么呢？"></a>问题：主动的放弃运行让系统调度的意义是什么呢？</h1><p>为了等待资源、事件，那么你需要进入等待队列。如果你已经拥有运行所需资源，却让系统调度，这是资源的浪费，并且调度也是要浪费资源的</p><p>解释：对的，你要等待资源，你确实需要排队，假如AB两个线程为合作关系，A线程处理一些原始数据，数据处理到一定程度，交给B线程处理，在A处理原始数据的时候，B也要做一些准备工作，所以，AB是并发的，但是B做好准备之后，需要等待A处理好那些数据，接过A的数据，继续处理，因此，这个等待，如果A不使用信号或者等待条件来通知B的话，那么B必须一直轮询，查看A是否已完成，B线程所做的这个轮询是否会一直占用CPU来做无用的循环查看呢？因此B这个时候占用的cpu时间片做的是无用功，因此，这里sleep(0)就有作用，当B查看A没处理完数据的时候，B马上sleep(0)交出B的时间片，让操作系统调度A来运行(假设只有AB两个线程），那么这个时候，A就会得到充分的时间来处理它的数据，这个不是一个应用了吗？我猜测pthread_conn_wait()内部阻塞就是使用这个机制</p><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">thread_fun</span>()</span><br><span class="line">&#123;</span><br><span class="line">    prepare_word.....</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A is finish)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">0</span>); <span class="comment">//这里会交出B的时间片，下一次调度B的时候，接着执行这个循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    process A's data</span><br></pre></td></tr></table></figure><p>没有sleep(0)版：<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">thread_fun</span>()</span><br><span class="line">&#123;</span><br><span class="line">    prepare_word.....</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)  <span class="comment">//这里会一直浪费CPU时间做死循环的轮询，无用功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A is finish)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process A's data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果说是轮询，那它就是一种高效、节约、谦虚的轮询，如果没有sleep(0)，那么B线程可能会执行上万次的while循环，直至它的时间片消耗完，做这些都是无用功，而是用了sleep(0)后，B线程每一次执行就只做一次while循环就把剩余的时间片让出给A，能让A得到更多的执行次数,利用率更高</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>在线程没退出之前，线程有三个状态，就绪态，运行态，等待态。sleep(n)之所以在n秒内不会参与CPU竞争，是因为，当线程调用sleep(n)的时候，线程是由运行态转入等待态，线程被放入等待队列中，等待定时器n秒后的中断事件，当到达n秒计时后，线程才重新由等待态转入就绪态，被放入就绪队列中，等待队列中的线程是不参与cpu竞争的，只有就绪队列中的线程才会参与cpu竞争，所谓的cpu调度，就是根据一定的算法（优先级，FIFO等。。。），从就绪队列中选择一个线程来分配cpu时间。</p><p>而sleep(0)之所以马上回去参与cpu竞争，是因为调用sleep(0)后，因为0的原因，线程直接回到就绪队列，而非进入等待队列，只要进入就绪队列，那么它就参与cpu竞争。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？Thread.Sleep(0) 表示挂起0毫秒，你可能觉得没作用，你要写Thread.Sleep(1000) 就有感觉了。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>restful最佳实践</title>
    <link href="https://xiaomo.info/2019/restfulBestUse/"/>
    <id>https://xiaomo.info/2019/restfulBestUse/</id>
    <published>2019-07-22T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.652Z</updated>
    
    <content type="html"><![CDATA[<p>restful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。它的大原则容易把握，但是细节不容易做对。<br><a id="more"></a></p><h4 id="不要纠结于无意义的规范"><a href="#不要纠结于无意义的规范" class="headerlink" title="不要纠结于无意义的规范"></a>不要纠结于无意义的规范</h4><p>  在开始本文之前，我想先说这么一句：RESTful 真的很好，但它只是一种软件架构风格，过度纠结如何遵守规范只是徒增烦恼，也违背了使用它的初衷。</p><p>  就像 Elasticsearch 的 API 会在 GET 请求中直接传 JSON，但这是它的业务需要，因为普通的 Query Param 根本无法构造如此复杂的查询 DSL。Github 的 V3 API 中也有很多不符合标准的地方，这也并不会妨碍它成为业界 RESTful API 的参考标准。</p><p>  我接下来要介绍的一些东西也会跟标准不符，但这是我在实际开发中遇到过、困扰过、思考过所得出的结论，所以才是<q>我所认为的</q>RESTful API 最佳实践。</p><h1 id="为什么要用-RESTful"><a href="#为什么要用-RESTful" class="headerlink" title="为什么要用 RESTful"></a>为什么要用 RESTful</h1><p> RESTful 给我的最大感觉就是规范、易懂和优雅，一个结构清晰、易于理解的 API 完全可以省去许多无意义的沟通和文档。并且 RESTful 现在越来越流行，也有越来越多优秀的周边工具（例如文档工具 Swagger）。</p><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>  如果能全站 HTTPS 当然是最好的，不能的话也请尽量将登录、注册等涉及密码的接口使用 HTTPS。</p><h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p> API 的版本号和客户端 APP 的版本号是毫无关系的，不要让 APP 将它们用于提交应用市场的版本号传递到服务器，而是提供类似于<code>v1</code>、<code>v2</code>之类的 API 版本号。版本号只允许枚举，不允许判断区间。</p><p>  版本号拼接在 URL 中或是放在 Header 中都可以。例如：</p> <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">api<span class="selector-class">.xxx</span><span class="selector-class">.com</span>/v1/users</span><br></pre></td></tr></table></figure><p>  或：</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">api.xxx.com/users</span><br><span class="line"> <span class="attribute">version</span>=v1</span><br></pre></td></tr></table></figure><h1 id="URL-设计"><a href="#URL-设计" class="headerlink" title="URL 设计"></a>URL 设计</h1><h3 id="动词-宾语"><a href="#动词-宾语" class="headerlink" title="动词+宾语"></a>动词+宾语</h3><p>RESTful 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构。比如，GET /articles这个命令，GET是动词，/articles是宾语。<br>动词通常就是五种 HTTP 方法，对应 CRUD 操作。</p><h3 id="动词的覆盖"><a href="#动词的覆盖" class="headerlink" title="动词的覆盖"></a>动词的覆盖</h3><p>有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。<br>这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。</p><h3 id="宾语必须是名词"><a href="#宾语必须是名词" class="headerlink" title="宾语必须是名词"></a>宾语必须是名词</h3><p>宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，/articles这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。</p><h3 id="复数-URL"><a href="#复数-URL" class="headerlink" title="复数 URL"></a>复数 URL</h3><p>既然 URL 是名词，那么应该使用复数，还是单数？<br>这没有统一的规定，但是常见的操作是读取一个集合，比如GET /articles（读取所有文章），这里明显应该是复数。<br>为了统一起见，建议都使用复数 URL，比如GET /articles/2要好于GET /article/2。</p><h3 id="避免多级-URL"><a href="#避免多级-URL" class="headerlink" title="避免多级 URL"></a>避免多级 URL</h3><p>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">GET <span class="regexp">/authors/</span><span class="number">12</span><span class="regexp">/categories/</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。<br>更好的做法是，除了第一级，其他级别都用查询字符串表达。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /authors/12?<span class="attribute">categories</span>=2</span><br></pre></td></tr></table></figure><h1 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h1><p>一般来说 API 的外在形式无非就是增删改查（当然具体的业务逻辑肯定要复杂得多），而查询又分为详情和列表两种，在 RESTful 中这就相当于通用的模板。例如针对文章（Article）设计 API，那么最基础的 URL 就是这几种：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">GET <span class="meta-keyword">/articles/</span>list： 文章列表</span><br><span class="line">GET <span class="meta-keyword">/articles/</span>detail<span class="class">/&#123;id&#125;：文章详情</span></span><br><span class="line"><span class="class">POST <span class="meta-keyword">/articles/</span>create/： 创建文章</span></span><br><span class="line"><span class="class">PUT <span class="meta-keyword">/articles/</span>update/&#123;id&#125;：修改文章</span></span><br><span class="line"><span class="class">DELETE <span class="meta-keyword">/articles/</span>delete/&#123;id&#125;：删除文章</span></span><br></pre></td></tr></table></figure><p> RESTful 中使用 GET、POST、PUT 和 DELETE 来表示资源的查询、创建、更改、删除，并且除了 POST 其他三种请求都具备幂等性（多次请求的效果相同）。需要注意的是 POST 和 PUT 最大的区别就是幂等性，所以 PUT 也可以用于创建操作，只要在创建前就可以确定资源的 id。</p><p>  将 id 放在 URL 中而不是 Query Param 的其中一个好处是可以表示资源之间的层级关系，例如文章下面会有评论（Comment）和点赞（Like），这两项资源必然会属于一篇文章，所以它们的 URL 应该是这样的：</p><p>评论：<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">GET <span class="string">/articles/</span>&#123;aid&#125;<span class="string">/comments</span>： 某篇文章的评论列表</span><br><span class="line">GET <span class="string">/comments/</span>&#123;cid&#125;<span class="string">/get</span>： 获取</span><br><span class="line">POST <span class="string">/articles/</span>&#123;aid&#125;<span class="string">/comments/create</span>： 在某篇文章中创建评论</span><br><span class="line">PUT <span class="string">/comments/</span>&#123;cid&#125;<span class="string">/update</span>： 修改评论</span><br><span class="line">DELETE <span class="string">/comments/</span>&#123;cid&#125;<span class="string">/delete</span>： 删除评论</span><br></pre></td></tr></table></figure></p><p>  这里有一点比较特殊，永远去使用可以指向资源的的最短 URL 路径，也就是说既然<code>/comments/{cid}</code>已经可以指向一条评论了，就不需要再用<code>/articles/{aid}/comments/{cid}</code>特意的指出所属文章了。</p><p>点赞：<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">GET <span class="string">/articles/</span>&#123;id&#125;<span class="string">/like</span>：查看文章是否被点赞</span><br><span class="line">PUT <span class="string">/articles/</span>&#123;id&#125;<span class="string">/like</span>：点赞文章</span><br><span class="line">DELETE <span class="string">/articles/</span>&#123;id&#125;<span class="string">/like</span>：取消点赞</span><br></pre></td></tr></table></figure></p><p>由于大部分的关系查询都与当前的登录用户有关，所以也可以直接在关系所属的资源中返回关系状态。例如点赞状态就可以直接在获取文章详情时返回。注意这里我选择了 PUT 而不是 POST，因为我觉得点赞这种行为应该是幂等的，多次操作的结果应该相同。</p><h1 id="Token-和-Sign"><a href="#Token-和-Sign" class="headerlink" title="Token 和 Sign"></a>Token 和 Sign</h1><p>API 需要设计成无状态，所以客户端在每次请求时都需要提供有效的 Token 和 Sign，在我看来它们的用途分别是：</p><ul><li>Token 用于证明请求所属的用户，一般都是服务端在登录后随机生成一段字符串（UUID）和登录用户进行绑定，再将其返回给客户端。Token 的状态保持一般有两种方式实现：一种是在用户每次操作都会延长或重置 TOKEN 的生存时间（类似于缓存的机制），另一种是 Token 的生存时间固定不变，但是同时返回一个刷新用的 Token，当 Token 过期时可以将其刷新而不是重新登录。</li><li>Sign 用于证明该次请求合理，所以一般客户端会把请求参数拼接后并加密作为 Sign 传给服务端，这样即使被抓包了，对方只修改参数而无法生成对应的 Sign 也会被服务端识破。当然也可以将时间戳、请求地址和 Token 也混入 Sign，这样 Sign 也拥有了所属人、时效性和目的地。</li></ul><h1 id="统计性参数"><a href="#统计性参数" class="headerlink" title="统计性参数"></a>统计性参数</h1><p>  我不太清楚这类参数具体该被称为什么，总之就是用户的各种隐私【误。类似于经纬度、手机系统、型号、IMEI、网络状态、客户端版本、渠道等，这些参数会经常收集然后用作运营、统计等平台，但是在大部分情况下他们是与业务无关的。这类参数变化不频繁的可以在登录时提交，变化比较频繁的可以用轮训或是在其他请求中附加提交。</p><h1 id="业务参数"><a href="#业务参数" class="headerlink" title="业务参数"></a>业务参数</h1><p>  在 RESTful 的标准中，PUT 和 PATCH 都可以用于修改操作，它们的区别是 PUT 需要提交整个对象，而 PATCH 只需要提交修改的信息。但是在我看来实际应用中不需要这么麻烦，所以我一律使用 PUT，并且只提交修改的信息。<br>  另一个问题是在 POST 创建对象时，究竟该用表单提交更好些还是用 JSON 提交更好些。其实两者都可以，在我看来它们唯一的区别是 JSON 可以比较方便的表示更为复杂的结构（有嵌套对象）。另外无论使用哪种，请保持统一，不要两者混用。<br>  还有一个建议是最好将过滤、分页和排序的相关信息全权交给客户端，包括过滤条件、页数或是游标、每页的数量、排序方式、升降序等，这样可以使 API 更加灵活。但是对于过滤条件、排序方式等，不需要支持所有方式，只需要支持目前用得上的和以后可能会用上的方式即可，并通过字符串枚举解析，这样可见性要更好些。例如：<br>  搜索，客户端只提供关键词，具体搜索的字段，和搜索方式（前缀、全文、精确）由服务端决定：</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/users/?<span class="attribute">query</span>=ScienJus</span><br></pre></td></tr></table></figure><p>  过滤，只需要对已有的情况进行支持：</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/users/?<span class="attribute">gender</span>=1</span><br></pre></td></tr></table></figure><p>  对于某些特定且复杂的业务逻辑，不要试图让客户端用复杂的查询参数表示，而是在 URL 使用别名：</p> <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/users/</span>recommend</span><br></pre></td></tr></table></figure><p>  分页：</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/users/?<span class="attribute">offset</span>=10&amp;limit=10</span><br><span class="line"> /articles/?<span class="attribute">cursor</span>=2015-01-01 15:20:30&amp;<span class="attribute">limit</span>=10</span><br><span class="line"> /users/?<span class="attribute">page</span>=2&amp;pre_page=20</span><br></pre></td></tr></table></figure><p>  排序，只需要对已有的情况进行支持：</p> <figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/articles/</span><span class="keyword">sort</span>=-create_date</span><br></pre></td></tr></table></figure><p> PS：我很喜欢这种在字段名前面加<code>-</code>表示降序排列的方式。</p><h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><p>HTTP 状态码就是一个三位数，分成五个类别。</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>xx：相关信息</span><br><span class="line"><span class="number">2</span>xx：操作成功</span><br><span class="line"><span class="number">3</span>xx：重定向</span><br><span class="line"><span class="number">4</span>xx：客户端错误</span><br><span class="line"><span class="number">5</span>xx：服务器错误</span><br></pre></td></tr></table></figure><p>这五大类总共包含100多种状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。<br>API 不需要1xx状态码，下面介绍其他四类状态码的精确含义。</p><h3 id="2xx-状态码"><a href="#2xx-状态码" class="headerlink" title="2xx 状态码"></a>2xx 状态码</h3><p>200状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">GET:</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">POST:</span> <span class="number">201</span> <span class="string">Created</span></span><br><span class="line"><span class="attr">PUT:</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">PATCH:</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">DELETE:</span> <span class="number">204</span> <span class="literal">No</span> <span class="string">Content</span></span><br></pre></td></tr></table></figure><p>上面代码中，POST返回201状态码，表示生成了新的资源；DELETE返回204状态码，表示资源已经不存在。<br>此外，202 Accepted状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">202</span> Accepted</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "task": &#123;</span><br><span class="line">    "href": "/api/company/job-management/jobs/2130040",</span><br><span class="line">    "id": "2130040"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3xx-状态码"><a href="#3xx-状态码" class="headerlink" title="3xx 状态码"></a>3xx 状态码</h3><p>API 用不到301状态码（永久重定向）和302状态码（暂时重定向，307也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。<br>API 用到的3xx状态码，主要是303 See Other，表示参考另一个 URL。它与302和307的含义一样，也是”暂时重定向”，区别在于302和307用于GET请求，而303用于POST、PUT和DELETE请求。收到303以后，浏览器不会自动跳转，而会让用户</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">303</span> See Other</span><br><span class="line"><span class="attribute">Location</span>: /api/orders/12345</span><br></pre></td></tr></table></figure><h3 id="4xx-状态码"><a href="#4xx-状态码" class="headerlink" title="4xx 状态码"></a>4xx 状态码</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>xx状态码表示客户端错误，主要有下面几种。</span><br><span class="line"><span class="symbol">400 </span>Bad Request：服务器不理解客户端的请求，未做任何处理。</span><br><span class="line"><span class="symbol">401 </span>Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。</span><br><span class="line"><span class="symbol">403 </span>Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。</span><br><span class="line"><span class="symbol">404 </span><span class="keyword">Not</span> Found：所请求的资源不存在，或不可用。</span><br><span class="line"><span class="symbol">405 </span>Method <span class="keyword">Not</span> Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</span><br><span class="line"><span class="symbol">410 </span>Gone：所请求的资源已从这个地址转移，不再可用。</span><br><span class="line"><span class="symbol">415 </span>Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。</span><br><span class="line"><span class="symbol">422 </span>Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。</span><br><span class="line"><span class="symbol">429 </span>Too Many Requests：客户端的请求次数超过限额。</span><br></pre></td></tr></table></figure><h3 id="5xx-状态码"><a href="#5xx-状态码" class="headerlink" title="5xx 状态码"></a>5xx 状态码</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>xx状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</span><br><span class="line"><span class="symbol">500 </span>Internal Server <span class="keyword">Error</span>：客户端请求有效，服务器处理时发生了意外。</span><br><span class="line"><span class="symbol">503 </span>Service Unavailable：服务器无法处理请求，一般用于网站维护状态。</span><br></pre></td></tr></table></figure><p>  但是有些时候仅仅使用 HTTP 状态码没有办法明确的表达错误信息，所以我倾向于在里面再包一层自定义的返回码，例如：</p><p>  成功时：</p> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"成功"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  失败时：</p> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">-1000</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"用户名或密码错误"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>data</code>是真正需要返回的数据，并且只会在请求成功时才存在，<code>msg</code>只用在开发环境，并且只为了开发人员识别。客户端逻辑只允许识别<code>code</code>，并且不允许直接将<code>msg</code>的内容展示给用户。如果这个错误很复杂，无法使用一段话描述清楚，也可以在添加一个<code>doc</code>字段，包含指向该错误的文档的链接。</p><h1 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h1><h3 id="不要返回纯本文"><a href="#不要返回纯本文" class="headerlink" title="不要返回纯本文"></a>不要返回纯本文</h3><p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。<br>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。下面是一个例子。</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">GET <span class="meta-keyword">/orders/</span><span class="number">2</span> HTTP/<span class="number">1.1</span> </span><br><span class="line"><span class="symbol">Accept:</span> application/json</span><br></pre></td></tr></table></figure><h3 id="发生错误时，不要返回-200-状态码"><a href="#发生错误时，不要返回-200-状态码" class="headerlink" title="发生错误时，不要返回 200 状态码"></a>发生错误时，不要返回 200 状态码</h3><p>有一种不恰当的做法是，即使发生错误，也返回200状态码，把错误信息放在数据体里面，就像下面这样。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "status": "failure",</span><br><span class="line">  "data": &#123;</span><br><span class="line">    "error": "Expected at least two items in list."</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，解析数据体以后，才能得知操作失败。<br>这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">HTTP/1.1 <span class="number">400</span> Bad Request</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "error": "Invalid payoad.",</span><br><span class="line">  "detail": &#123;</span><br><span class="line">     "surname": "This field is required."</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提供链接"><a href="#提供链接" class="headerlink" title="提供链接"></a>提供链接</h3><p>API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。<br>举例来说，GitHub 的 API 都在 api.github.com 这个域名。访问它，就可以得到其他 URL。</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="string">"feeds_url"</span>: <span class="string">"https://api.github.com/feeds"</span>,</span><br><span class="line">  <span class="string">"followers_url"</span>: <span class="string">"https://api.github.com/user/followers"</span>,</span><br><span class="line">  <span class="string">"following_url"</span>: <span class="string">"https://api.github.com/user/following&#123;/target&#125;"</span>,</span><br><span class="line">  <span class="string">"gists_url"</span>: <span class="string">"https://api.github.com/gists&#123;/gist_id&#125;"</span>,</span><br><span class="line">  <span class="string">"hub_url"</span>: <span class="string">"https://api.github.com/hub"</span>,</span><br><span class="line">  <span class="string">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。</p><p>HATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "status": "In progress",</span><br><span class="line">   "links": &#123;[</span><br><span class="line">    &#123; "rel":"cancel", "method": "delete", "href":"/api/status/12345" &#125; ,</span><br><span class="line">    &#123; "rel":"edit", "method": "put", "href":"/api/status/12345" &#125;</span><br><span class="line">  ]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON 比 XML 可视化更好，也更加节约流量，所以尽量不要使用 XML。<br>创建和修改操作成功后，需要返回该资源的全部信息。<br>返回数据不要和客户端界面强耦合，不要在设计 API 时就考虑少查询一张关联表或是少查询 / 返回几个字段能带来多大的性能提升。并且一定要以资源为单位，即使客户端一个页面需要展示多个资源，也不要在一个接口中全部返回，而是让客户端分别请求多个接口。<br>最好将返回数据进行加密和压缩，尤其是压缩在移动应用中还是比较重要的。</p><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>  在 <a href="http://www.scienjus.com/app-server-paging/" target="_blank" rel="noopener">APP 后端分页设计</a> 中提到过，分页布局一般分为两种，一种是在 Web 端比较常见的有底部分页栏的电梯式分页，另一种是在 APP 中比较常见的上拉加载更多的流式分页。这两种分页的 API 到底该如何设计呢？</p><p>  电梯式分页需要提供<code>page</code>（页数）和<code>pre_page</code>（每页的数量）。例如：</p> <figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta-keyword">/users/</span>?page=<span class="number">2</span><span class="variable">&amp;pre_page</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure><p>  而服务端则需要额外返回<code>total_count</code>（总记录数），以及可选的当前页数、每页的数量（这两个与客户端提交的相同）、总页数、是否有下一页、是否有上一页（这三个都可以通过总记录数计算出）。例如：</p> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"pagination"</span>: &#123;</span><br><span class="line">       <span class="attr">"previous"</span>: <span class="number">1</span>,</span><br><span class="line">       <span class="attr">"next"</span>: <span class="number">3</span>,</span><br><span class="line">       <span class="attr">"current"</span>: <span class="number">2</span>,</span><br><span class="line">       <span class="attr">"per_page"</span>: <span class="number">20</span>,</span><br><span class="line">       <span class="attr">"total"</span>: <span class="number">200</span>,</span><br><span class="line">       <span class="attr">"pages"</span>: <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  流式布局也完全可以使用这种方式，并且不需要查询总记录数（好处是减少一次数据库操作，坏处时客户端需要多请求一次才能判断是否到最后一页）。但是会出现数据重复和缺失的情况，所以更推荐使用游标分页。</p><p>  游标分页需要提供<code>cursor</code>(下一页的起点游标) 和<code>limit</code>(数量) 参数。例如：</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/articles/?<span class="attribute">cursor</span>=2015-01-01 15:20:30&amp;<span class="attribute">limit</span>=10</span><br></pre></td></tr></table></figure><p>  如果文章列表默认是以创建时间为倒序排列的，那么<code>cursor</code>就是当前列表最后一条的创建时间（第一页为当前时间）。</p><p>  服务端需要返回的数据也很简单，只需要以此游标为起点的总记录数和下一个起点游标就可以了。例如：</p> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"pagination"</span>: &#123;</span><br><span class="line">       <span class="attr">"next"</span>: <span class="string">"2015-01-01 12:20:30"</span>,</span><br><span class="line">       <span class="attr">"limit"</span>: <span class="number">10</span>,</span><br><span class="line">       <span class="attr">"total"</span>: <span class="number">100</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果<code>total</code>小于<code>limit</code>，就说明已经没有数据了。</p><p>  流式布局的分页 API 还有一种情况很常见，就是下拉刷新的增量更新。它的业务逻辑正好和游标分页相反，但是参数基本一样：</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/articles/?<span class="attribute">cursor</span>=2015-01-01 15:20:30&amp;<span class="attribute">limit</span>=20</span><br></pre></td></tr></table></figure><p>  返回数据有两种可能，一种是增量更新的数据小于指定的数量，就直接将全部数据返回（这个数量可以设置的相对大一些），客户端会将这些增量更新的数据添加在已有列表的顶部。但是如果增量更新的数据要大于指定的数量，就会只返回最新的 n 条数据作为第一页，这时候客户端需要清空之前的列表。例如：</p> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"pagination"</span>: &#123;</span><br><span class="line">       <span class="attr">"limit"</span>: <span class="number">20</span>,</span><br><span class="line">       <span class="attr">"total"</span>: <span class="number">100</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果<code>total</code>大于<code>limit</code>，说明增量的数据太多所以只返回了第一页，需要清空旧的列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;restful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。它的大原则容易把握，但是细节不容易做对。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="java" scheme="https://xiaomo.info/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>小莫的日本换驾照攻略</title>
    <link href="https://xiaomo.info/2019/nihonnmennkyo/"/>
    <id>https://xiaomo.info/2019/nihonnmennkyo/</id>
    <published>2019-05-31T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.652Z</updated>
    
    <content type="html"><![CDATA[<p>虽然没有100%确定要在日本定居，但是也不能像咸鱼一样度日。而且日本的驾照可以作为身份证明使用（有些日企在填资料时有一项是填：是否有驾照），所以便有准备考驾照，当然以后自驾游啥的也是很方便。在准备考试的过程中经过多方了解和调查获取了许多相关知识，所以准备以blog的形式记录下来。一是把内容整理出来方便自己更好的通过考试，也可以方便在日本想要换驾照的朋友提供个参照。（本篇文章历时2周，花费时间5个小时左右）<br><a id="more"></a></p><h1 id="换驾照和住所有关"><a href="#换驾照和住所有关" class="headerlink" title="换驾照和住所有关"></a>换驾照和住所有关</h1><p>因为我住在琦玉，所以换驾照是去<code>埼玉県鴻巣市鴻巣405番地</code>警察署，具体移步<a href="https://www.police.pref.saitama.lg.jp/f0130/menkyo/gaikoku.html" target="_blank" rel="noopener">琦玉警察署</a>，还有一种不需要和住所绑定，也就是报一个华人驾校，费用在3-4万左右。由于我准备硬刚，所以没有做这种方式的相关攻略，我同事选的这个方式目前己拿到驾照。如果万一对自己没有信心的话可以找个技能学习中心学几节课，费用在2万左右。不管怎么说换驾照都比直接考要便宜，我有个朋友10连休去学的驾照花了20多万，12天拿到驾照。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>资料审核时间是工作日的早上9:30-10:30,和下午的1:30-2:00，各半小时（政府单位就是这么任性）。如果要当天考视力和笔试必须得上午去，下午1点钟考。</li><li>在国内拿到驾照之后需要待满3个月以上才能过来换。</li><li>如果日语不好需要有人陪同，会问一些简单的情况。</li><li>如果戴眼镜的话会被做标记限制只能戴眼镜开车，很在意这个测视力的时候可以戴隐形假装自己不近视。（看的别人的攻略，个人觉得没必要这样弄虚作假）</li><li>考试内容的话概括是视力测试;10道题的理论测试，7道以上合格;类似国内科二跑一圈。扣分制，70分以下考官会叫停。</li><li>日本是右舵，跟国内相反。不过看到这个攻略的人应该都知道这个情况。</li><li>台湾护照可以不经过考试直接换日本驾照。</li></ol><h1 id="费用"><a href="#费用" class="headerlink" title="费用"></a>费用</h1><ol><li>报名费 2550　（意味着挂几次就要出几次2550）</li><li>领取驾照 2050 （工本费，考过后出一次）</li></ol><h1 id="需要的资料"><a href="#需要的资料" class="headerlink" title="需要的资料"></a>需要的资料</h1><ol><li>在留卡原件</li><li>护照。用来确认在居留期限及出入国境的记录。</li><li>1寸照片（3X2.4），两张或以上。日本的车站里的写真机器或者便利店里的打印机都可以弄。</li><li>登录所有信息的住民票</li><li>中国驾驶证。（原件。JAF及各县交通局会拿去复印。需要在取证之后的3个月内没有出中国的记录。）</li><li>JAF（Japan Automobile Federation日本汽车联盟）翻译件，可以去JAF窗口也可以邮寄。费用 3500，具体请移步<a href="http://www.jaf.or.jp/inter/translation/" target="_blank" rel="noopener">JAF</a></li><li>国内的成绩单和个人信息表，不需要翻译件</li></ol><h1 id="中文PDF说明文件"><a href="#中文PDF说明文件" class="headerlink" title="中文PDF说明文件"></a>中文PDF说明文件</h1><p><a href="https://www.keishicho.metro.tokyo.jp/multilingual/chinese/traffic_safety/drivers_licenses/index.files/convert_license_chinese.pdf" target="_blank" rel="noopener">外国驾照更换日本驾照</a></p><h1 id="考试经过"><a href="#考试经过" class="headerlink" title="考试经过"></a>考试经过</h1><ol><li>坐电梯上2楼右转再右转，到<code>外国人免许相谈室</code>门口排队，等待资料审核。会问一些国内考驾照的细节，需要有一定的日语基础。（不会日语需要自带翻译）</li><li>下午1点前到1楼大厅左侧3-4号排队检查视力，然后考10道理论题，7道以上合格。（正常人都能通过）</li><li>通过之后就会被带到场地上车考试，场地有很多小牌子，考官会提前发出指令。对牌子的位置不熟的话很快就会挂掉！！！<a href="https://blog.xiaomo.info/2019/nihonnmennkyo/#最后配一张琦玉考试的平面路线图" target="_blank" rel="noopener">参考</a></li><li>我在考到一半的时候被叫停挂掉，最大原因就是对场地不熟悉（毕竟没练过），开车的时候不停的在找牌子就这样挂掉了，预约在半个月后（6/24）再次考试。</li><li>参考考试结果觉得不练一下还是比较难考过，果断找了一家驾校准备去练几节课。</li></ol><h1 id="练车心得"><a href="#练车心得" class="headerlink" title="练车心得"></a>练车心得</h1><p>2019/6/10去驾校练车，由于平日练车的人不多所以直接一次性练了3节课（<code>3280*3</code>），练车后觉得还是挺有帮助的。</p><ol><li>上车前：从副驾侧绕到车头中间后退3步蹲下看车底和轮胎，然后从副驾侧绕道车尾后退3步蹲下看车底和轮胎 检查有没有小动物，儿童，或障碍物，有没有漏油，变形，车轮是否回正等。确认无误后，从后面绕到车右侧开门上车。。（不能从车头直接绕到驾驶室）</li><li>上车时：先看后方，无人时把车门开一个缝，然后再扭头观察后方。无车情况下打开车门进入驾驶室。坐下后关车门：关车门分两段，先虚掩一下车门，确认不会夹到东西，再用力关上，关上后顺便锁车门！不锁车门会扣分。然后向考官问好：こんにちは，留个好印象。</li><li>打火前准备：调节座椅位置，调节车内后视镜（就算合适也要调整，要有这个动作），系上安全带，并告诉考官 シートベルト(seat belt)お願いいたします。如果车轮没有回正的话，把车轮回正。依次摸一下档位和手刹，确认手刹已经拉上，档位在P档，雨刮，灯光拨杆位置都正确。确认的时候可以用手指一个一个点过去做确认状。然后踩着刹车，发动引擎，启动后确认车况和指示灯无异常。</li><li>打火后准备：调节左右2个后视镜，如果下雨情况下要打开雨刷。（没打火调不了左右后视镜）准备完之后告诉考官 準備終わりました。</li><li>当考官告诉你 出発，回答　はい。然后挂D档，松手刹，打右转灯。依次扭头确认后方，左后视镜，车内后视镜，右后视镜，右侧，扭头看右向方（记住一定要回头！不然会扣分！扣分！分！），没车的情况下松开刹车起步。</li><li>进入主道前要停车，依次观察车内后视镜，右方后视镜，右后方，无车情况下方可进入。</li><li>过弯道后进入直道要加速至35-40码，进入弯道前减速。</li></ol><hr><ol start="8"><li>此时考官会说 <code>3</code>番：右，到<code>33</code>号附近（提前30米）打右转灯。确认车内后视镜，右方后视镜，右后方。无车开始向右并线，到<code>3号</code>再次3点确认后右转到左道上，然后此直道上要加速到35-40码。</li><li>此时考官会说 <code>35</code>番：右，打右转灯，右方3点确认。可在上一步的基础上贴近右侧线，到<code>35号</code>前再次右方3次确认进入<code>直接弯</code>。</li><li>此时考官会说 <code>38</code>番：右，打右转灯，在路口停车以此确认左后视镜，车内后视镜，右后视镜，右方，然后看着左方没车的时候拐入左侧道路。</li><li>此时考官会说 <code>2</code>番：左，此时离2号还隔着一个<code>红绿灯</code>，不要急着打灯。正常通过红绿灯后，打左转灯。然后依次左方3点确认后开始向左并线。在2号时停车看右方，右后视镜，车内后视镜，左边后视镜，左前方，然后看下右方没车转向左道。</li><li>此时考官会说 <code>1</code>番：左，打左转打。左方3点确认，没车的话往左并线。到了<code>1号</code>后停车左方3点确认没车的话进入左道，前方直接要加速到35-40码。前方十字路口<code>有树（見通し悪い場所）</code>，要降速至10码以下到达路口时要前倾以右左右的顺序确认缓慢通过。</li><li>此时考官会说 <code>50</code>番：左，打左转灯，左方3点确认，向左并线。到达50号时再次左方3点确认，没车时开始进入<code>S弯</code>。</li><li>此时考官会说 <code>49</code>番：右，在路口时要停车看右前方，车内后视镜，左前方，没车时右转到左道。</li><li>此时考官会说 <code>16</code>番：左，打左转灯，左方3点确认，并线至左边。然后到达<code>16</code>号时<code>停车3秒(止まれ)</code>,不停会挂掉。看右前，车内后视镜，左侧后视镜，扭头看后方。然后看下右方没车的话开始左转。前方有一个路口，减速通过。然后有一个人行道，减速通过。</li><li>此时考官会说 <code>14</code>番：左，打左转灯。左方3点确认，开始向左并线。到达<code>14</code>号再次3点确认，没车时开始左转。前人有一个红绿灯，注意看灯。通过后加速到35-40码。</li><li>此时考官会说 <code>4</code>番：右，打右转打，右方3点确认，并线到右边。到达4号后再次右方3点确认，看下左边没车的话开始进入左道。</li><li>此时考官会说 <code>8</code>番：右，打右转打，右方3点确认，向右侧并线。同样也要反复左右偏头确认后再进入左侧道路。前方<code>有树（見通し悪い場所）</code>，要路口前要减速到10码以下，以右左右的顺序确认缓慢通过。</li><li>此时考官会说 <code>10</code>番：右，打右转灯，右方3点确认，然后向右侧并线。到达10号再次右方3点确认，并进入左道。此时加速至40-50， 前方有<code>障碍物</code>，还有50米左右时打右转灯，然后右方3点确认，打30度方向盘加速进入右道，车子摆正后打左转灯，到达障碍物时左方3点确认，没车时打30度方向盘并入左侧。前方过弯道后打左转灯，左方3点确认。没车时进入左道。</li><li>此时考官会说 <code>左</code> 终点停車,减速，打左灯，回头看，贴边，在指定的位置慢慢停住。（左侧30CM以内，左前方铁栏杆50CM以内）。</li></ol><hr><ol start="22"><li>先拉手刹（不用按），然后挂P档。如果雨刷打开着的话要向前推关掉雨刷，熄火。把座椅推到最后，然后解掉安全带。把车门打开一个缝，观察后方安全推开车门，一只脚踏出去后告诉考官 終わりました。</li><li>从车的后方绕到考官的左侧车窗，听候发落。。</li><li>车开到终点，考官会根据你的表现告诉你及不及格，合格的话归还号码牌，不合格的话会还你申请资料。有时候考官会问你两句，比如说你之前练了多久的车，在哪个驾校练的，这是第几次考试了之类的，有时候结果介于及格和不及格之间的话，回答没怎么练过，或者驾校的名声比较臭的话容易给不及格。不及格的话一般考官会告诉你扣分点在哪里，你是怎么错的，不过一般也就说一两个地方，如果错的比较多的话考官不会全部都告诉你，但是如果教官完全没说的话你可以开口问，考官是有义务告知你的，问的话不会不说。等说完之后就按照指示去约下一次的考试。及格的话，去换证窗口办手续，按照指示等两三个小时，就可以领到驾照了。最后祝换证的朋友们都能一切顺利！</li></ol><h1 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>打方向盘不要太急，不稳会扣分。</li><li>打方向盘一次不要太多，回盘一次扣5分。</li><li>止まれ 不停车会被直接踩停挂掉考试;红灯不停会被踩停挂掉考试;逆行会被踩停挂掉考试。</li><li>考试前拿着路线图实地进场走一走，再熟悉一遍(11:45~12:45)。</li><li>要先打灯后确认，到达目的地点后再次确认方可动盘。</li><li>确认的时候要保持方向盘水平且不能动盘。</li><li>有树的地方（見通し悪い場所）一定要减速并左右观察确定。</li><li>路线一定要熟记，在哪往哪转提前心里要有谱。</li></ol><h1 id="友情提示"><a href="#友情提示" class="headerlink" title="友情提示"></a>友情提示</h1><ol><li>日本驾照的扣分是：每个月有3分。各种违章，按轻重扣分不同。比如15号，你的3分扣完了，那么你这个月就不能再开车了。但下个月自动还是有3分的。</li><li>开车的时候，一定不要喝酒，一口都不行，因为你考回来的驾照会被吊销！另外，安全带，上车后必须系上！必须！包括副驾驶的！如果副驾驶没有系安全带，警察看到后，司机的驾照仍旧会被扣分。</li><li>普通道路的时候，可以稍微超速，80km/h的限速，开到120km/h的也大有人在，只是有被扣分罚钱的危险。</li></ol><h1 id="最后配一张琦玉考试的平面路线图"><a href="#最后配一张琦玉考试的平面路线图" class="headerlink" title="最后配一张琦玉考试的平面路线图"></a>最后配一张琦玉考试的平面路线图</h1><p><img src="/img/blog/saitama.png" alt></p><h1 id="更加真实一点的地图"><a href="#更加真实一点的地图" class="headerlink" title="更加真实一点的地图"></a>更加真实一点的地图</h1><p><img src="/img/blog/course.jpg" alt></p><h1 id="20190820更新"><a href="#20190820更新" class="headerlink" title="20190820更新"></a>20190820更新</h1><p>在昨天，终于拿到了驾照，不负这段付出的时光，希望每个努力的人都有一个好结果。<br><img src="/img/blog/menkyo.jpg" alt></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.infukuoka.info/life/5168.html" target="_blank" rel="noopener">中国驾照转日本驾照超详细攻略！</a></li><li><a href="https://blog.xiangzhuyuan.com/tranfer-chinese-driver-license-to-japanese/" target="_blank" rel="noopener">东京换驾照记</a></li><li><a href="https://baijiahao.baidu.com/s?id=1595714456461270665&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">日本留学 ｜ 如何在日本换驾照</a></li><li><a href="http://mini.eastday.com/bdmip/180404112201086.html#" target="_blank" rel="noopener">YMG教你中国驾照如何换日本驾照</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然没有100%确定要在日本定居，但是也不能像咸鱼一样度日。而且日本的驾照可以作为身份证明使用（有些日企在填资料时有一项是填：是否有驾照），所以便有准备考驾照，当然以后自驾游啥的也是很方便。在准备考试的过程中经过多方了解和调查获取了许多相关知识，所以准备以blog的形式记录下来。一是把内容整理出来方便自己更好的通过考试，也可以方便在日本想要换驾照的朋友提供个参照。（本篇文章历时2周，花费时间5个小时左右）&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://xiaomo.info/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://xiaomo.info/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>日本的生活日常</title>
    <link href="https://xiaomo.info/2019/nihonnkita2kagetsu/"/>
    <id>https://xiaomo.info/2019/nihonnkita2kagetsu/</id>
    <published>2019-02-24T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.652Z</updated>
    
    <content type="html"><![CDATA[<p>来日本也差不多有2个月啦，这2个月时间也一直没有更新博客。主要是因为换了新环境很多事情需要做，很多地方需要适应，所以没时间也没法静下心来写写博客记录一下生活。现在终于有时间坐下来记录一下在日本的生活日常。<br><a id="more"></a></p><h1 id="我为什么要来日本"><a href="#我为什么要来日本" class="headerlink" title="我为什么要来日本"></a>我为什么要来日本</h1><p>大学的时候一直对动漫特别感觉趣，毕业后在杭州偶然接触到对日的软件开发，开始萌发了学日语的想法。后来看动漫的量越来越多，听力也慢慢好起来，开始有了到日本看一看的念头，但是因为能力受限一直没有到日本，但是在2015年~2018年期间有断断续续的背日语单词。17年国庆节的时候和老婆一起来日本自由行12天，亲眼见证了日本的自然和人文，便把到日本工作作为自己的下一个计划。大家应该都知道2018年是互联网很不好的一年，裁员风暴一波又一波，但是我的前公司并没有因此裁员反而吸收了大量被裁员的人。我15年进那家公司的时候不到60人，我18年离职的时候己经快1000人了，我亲眼见证了这家公司的飞速成长。但是为我什么离职呢，我在这家公司3年了也想换换新的环境，但是国内的环境不好自己带的那个项目表现不是很好又经常通宵加班所以趁此机会开始找日本的工作机会。从6月份开始通过猎头远程面试到7月份确定工作，然后就是各种证件EMS给公司办在留资格证。</p><h1 id="我来日本多久了"><a href="#我来日本多久了" class="headerlink" title="我来日本多久了"></a>我来日本多久了</h1><p>2018年8月份开始申请在留，2019年11月拿到手，但是很快到日本的新年了。所以我在农历的腊月中旬（2019.1.16）来到日本东京，2019年在日本度过了的第一个中国新年，正好今年东京塔在春节当晚亮起了中国红，刷爆了朋友圈,突然也有了一点恋家的感觉。我老家在非常偏僻的农村，后来了为读书我们搬到了镇上。考上了县城高中然后在县城买了房子。到后来读大学，去了武汉。毕业后和朋友一起到杭州谋生。现在都各自成家立业，朋友正在注册着属于自己的公司，而我飘扬过海来到日本工作。我一直不信星座，但是作为射手座的我，星座解释说射手座向往自由和远方，这一点我倒是深信不疑,从一个小村庄到出国，是射手座给我的勇气。截至到目前为止，我在日本待了大概有2个月，可能还会待很多个两个月。今年天皇退位,所以黄金周放10天假可以回杭州休息一段时间了。</p><h1 id="在日本住的房子是什么样的"><a href="#在日本住的房子是什么样的" class="headerlink" title="在日本住的房子是什么样的"></a>在日本住的房子是什么样的</h1><p>公司提供了3种方案：1、住公司宿舍——价格最便宜，也最省心，但是环境不是很好，地方也比较小。 2、在公司合租的中介那边自租房间——个人感觉价格比较贵，而且有朋友在日本工作，问我愿不愿意合租。 3、自理——我选择了自己搞定，在日本和朋友合租了UR团地，9万一个月，总面积54平，3DK。在房子上没有走很多才来日本的朋友的坑，这一点比较省心。但是由于住的地方比较远，所以上班时间得花1个多小时。不过和北上广比较来，也差不了太多。既然选择在大城市，就得有这个觉悟。</p><h1 id="在日本做什么样的工作"><a href="#在日本做什么样的工作" class="headerlink" title="在日本做什么样的工作"></a>在日本做什么样的工作</h1><p>我是2019年1月17号到达日本，来了之后公司催着去上班（我还以为是2.1号开始）。所以在17号当天急急忙忙办了各种手续。包括住民登记、办手机卡、办银行卡、去公司签协议等等。于是，在2019年2月18号，我正式开始了在日本的第一天社畜生活。我是在 在日华人在日本开的公司，属于派遣形式。第一个现场是在浦田，公司名字是日立制作所，我对日立印象最深的就是中国很多电梯都是三菱和日立的品牌。做的工作内容并没有什么技术性，短暂的做了一些测试的工作，在这期间我开始疯狂的记单词，没有工作任务的时候就记。好在这个现场的工作时间不长，2019年2月底就结束了，所以我开始面试新的项目，从3.1号开始到下个现场上班。说实话，因为自己日语口语太差，加上基本上没有对日开发经验，所以一度非常受挫。第一个面试的项目是在SoftBank，第二个是日本NSD,第三个是ricoh(理光)。第三个面上了，我特意去了解了一下是个世界500强的公司，还算是不错。工作内容是使用Angular6做网站开发，因为我经常不务正业研究一些乱七八糟的技术，包括但不限于Angular,React之类。在面试的时候虽然口语表达的不好，但是把自己Angular会的部分展示出来成功的获得了工作机会。还有最后2天就要开始做这个项目了，希望会是一个开心的过程。</p><h1 id="在日本的通讯方式"><a href="#在日本的通讯方式" class="headerlink" title="在日本的通讯方式"></a>在日本的通讯方式</h1><p>来日本的第一天匆匆忙忙办了一张Y！Mobile的手机卡，一个月2000日元，3GB流量。由于考虑手机用的比较久，电池不耐用，32G内存也不够用等等花了8万日元入手了一台256G的iphoneXR，办了一个SoftBank的卡，因为室友也用的SoftBank的卡，所以每个月还可以额外优惠1000日元。</p><h1 id="在日本吃什么"><a href="#在日本吃什么" class="headerlink" title="在日本吃什么"></a>在日本吃什么</h1><p>首先，我出生在内陆，很少吃海鲜，偶尔吃虾和鱼。来了日本之后看到鱼特别便宜但是却没有想吃的欲望觉得还是挺浪费的。正所谓入乡随俗，所以我也开始尝试一些日本料理，但是吃了一次生鱼片我确实还没法习惯。再加上店里吃饭比较贵，我一般都是自己做饭吃，带便当去现场中午吃。住的地方超市、便利店、物产店都很方便，想吃什么基本上都能买到。</p><h1 id="打算在日本待多久"><a href="#打算在日本待多久" class="headerlink" title="打算在日本待多久"></a>打算在日本待多久</h1><p>目前来说还没有确定，只能说走一步看一步。刚来日本各种东西不熟悉、语言不通、环境不适应等等各种因素我也打过退堂鼓，但是觉得自己努力了这么久才来了不到2个月，还得需要更多的时间去适应。</p><h1 id="日本的工作加班吗"><a href="#日本的工作加班吗" class="headerlink" title="日本的工作加班吗"></a>日本的工作加班吗</h1><p>做IT行业我说不加班你会信吗？ 你肯定会说：我信你鬼哟，你个糟老头子坏的很！ 确实，IT行业不需要和人打交道，有内容一直都可以做。但是日本确定很少加班，日本和中国不一样，日本是按照出勤时间算。比如说一天上班8小时，一个月上20天。所以日本普遍月出勤时间在150-160之间。到了下班时间还在公司墨迹领导会催着回去，而且有些公司规定周三、周五强制6点离场。在现在这个现场我偶尔也有加班，但是最晚是到8点钟，这样的话我出勤时间就有10个小时。我之后如果有事情要办，可以调休去办自己的事情，只要总工时达到了规定时间就能发全工资，所以我觉得这一点还是比较人性化。</p><h1 id="日本的社保"><a href="#日本的社保" class="headerlink" title="日本的社保"></a>日本的社保</h1><p>日本有社保和厚生年金，年金和国内的一金非常类似，自己的公司各负担一半。社保可以不交，但是国民健康保险最好交一下，我现在每个月是2700日元。日本纳税是按照上一年度纳税，我第一年来日本所以比较低，明年的话可能一个月要交8000左右的保险金。这个国民健康保险看病自己只用负担30%，家人也可以用，小孩子是全免费的。有些不分大人小孩可吃的药医生出会多开一些剂量，不用出钱大人也可以用，比如说日本人春天物别容易犯的花粉症的抗过敏药。我到现在为止拿到了国民健康保险卡，这个月也刚交了2700的保险金，但是没有到医院去过，所以具体什么样子得等以后再实践。</p><h1 id="日本IT行业的那些规矩"><a href="#日本IT行业的那些规矩" class="headerlink" title="日本IT行业的那些规矩"></a>日本IT行业的那些规矩</h1><p>在日本做IT没有灵活可言，要用什么工具，什么版本基本上都是定好的，给什么用什么。有问题一定要及时和上级沟通，上级会很认真的帮忙解决，自己想当然做到最后出问题会很严重，一直出错最终会失去领导的信任。在工位上可以玩手机，可以充电啥的，但是绝对不要把USB插到电脑上，也不要在办公室拍照。日本人上班工作喝水基本上都是在自动贩卖机上买各种饮料或矿泉水，目前只有我一个人会抱着个大大的保温杯去接开水喝，而且日本人食量很小，我每天中午都吃的是我们领导的2倍多，才开始还觉得有点羞耻，后来脸厚了也就无畏无惧了。我现在工作的地方允许在工位上吃饭，可能有些地方会不让。</p><h1 id="在日本的中国人可信吗"><a href="#在日本的中国人可信吗" class="headerlink" title="在日本的中国人可信吗"></a>在日本的中国人可信吗</h1><p>来日本之前看过很多文章说中国人坑中国人，首先我觉得比较丢脸，因为我也是中国人，但是我觉得事实上并没有说的那么严重。至少我来日本遇到的中国人都还是挺好的，包括我现在公司的社长、公司营业、办手机卡的中国营业员、项目组的中国人，感觉都还挺好的。目前没有出现被坑的情况，也希望以后不要遇到，不要让我也觉得国人坑国人是那么普遍。</p><h1 id="日本的卫生间"><a href="#日本的卫生间" class="headerlink" title="日本的卫生间"></a>日本的卫生间</h1><p>可能有朋友有觉得我把这个单独提出来是不是有点变态，其实我觉得是有些可以拿出来说的。首先，日本的卫生间干净的让人觉得十分舒服，完全没有味道。每个水龙头都有热水，旁边摆的洗手液永远都不会成空瓶子。有风干机，有镜子，每个马桶边上的纸从来不会空。总之，这些小细节真的是让人非常喜欢。</p><h1 id="办公室工作结构"><a href="#办公室工作结构" class="headerlink" title="办公室工作结构"></a>办公室工作结构</h1><p>我目前所在的项目是6个人，4个中国人和2个日本人。为了练日语，我会经常厚脸皮的和其中一个日本人发消息聊天，在没有工作内容的时候经常会一聊 聊半天时间。从开始打字都不知道打什么，到现在能长篇大论，从吃的谈到用的，从家庭谈到工作。我觉得我进步还是挺大的，但是目标最弱的还是口语，所以在接下来的时候我会努力的去读去练发声。</p><h1 id="非工作时间我一般在做什么"><a href="#非工作时间我一般在做什么" class="headerlink" title="非工作时间我一般在做什么"></a>非工作时间我一般在做什么</h1><p>来日本一个多月了，除了上班我感觉别的事情我真的什么都没做，但是总觉得时间一晃就非常晚了。一般来说，花1个多小时回家，再花1个小时做饭吃饭，再玩玩电脑玩玩手机不知不觉都己经过了12点。从高中开始一直对钢琴比较有兴趣，所以买了雅马哈的电钢琴但是也没什么时间练，但是它也是我以后其中计划的一环，总有一天我会流利的弹出我喜欢的钢琴曲。周六固定在日本政府办的免费日语教室上课，然后和朋友一起吃个晚饭。周末做家里蹲一睡一整天，其实我觉得这样很不好，这个我会尽量改掉。我一直计划想去海边去玩，但是因为温度比较低一直没有去，等天气暖和一点了去海边玩。在国内的时候玩着来日本了一有时间我就要出去各种浪，但是真正来了日本快2个月了一直没有出去玩过真是汗颜。</p><h1 id="日本的电车"><a href="#日本的电车" class="headerlink" title="日本的电车"></a>日本的电车</h1><p>日本的电车非常准时，我仔细注意过，我只要早上固定在某个时间点从家里出来，一定是在某个时间点到达公司。只有一次电车延迟了半个多小时，原因好像是我坐的这条线正好遇到了人身事故。日本的电车非常安静，日本人在电车上很喜欢看书。电车上明文规定手机保持震动，不要在车上打电话，所以车上非常安静。能听到别人说的悄悄话和翻书的声音。电车上有2个固定的显示屏，一个放广告一个放实时站点信息。不想看广告的话完全不会被打扰，屏幕上会有当天的天气预报。每个电车基本上都设置有3节女性车厢，早晚高峰最好不要坐，不然有可能会被白眼，其实这倒没什么，万一遇到蛮不讲理的女性非要说是痴汉会很伤脑筋。东京早晚高峰电车非常拥挤，这也是为什么男性要尽量避免女性专用车厢。但是平时的话很容易遇到座位，因为有很多日本人都不坐。据说是他们觉得会有比自己更需要座位的人，所以不是特别累就会站着，反正我是奉行有位置不坐是王八的バカ。</p><h1 id="日本的电梯文化"><a href="#日本的电梯文化" class="headerlink" title="日本的电梯文化"></a>日本的电梯文化</h1><p>我工作的现场有8个电梯，在两边都排着整齐的队伍。有电梯下来依次乘坐，坐不下的会退回来等下一部电梯。站的太满的时候靠近门的那部分人会先出来等别人都出来了再上去，电梯按钮边上的人也会帮忙一直把开的按钮一直按着，不会像国内站在里面想出来只能使劲挤出来。在坐电梯的时候如果门快关了有快速跑过来按开电梯，进来之前会先鞠躬道歉再过来。在按钮边上站着的人会按着开的按钮等所有人都出来了他们再出来，因为我没有这个习惯所以一到目的地楼层我就会先出来，所以心里会有点抱歉。</p><h1 id="来日本2个月的感觉"><a href="#来日本2个月的感觉" class="headerlink" title="来日本2个月的感觉"></a>来日本2个月的感觉</h1><p>首先从去市役所做住所登录来说，政府人员真的是非常非常有耐心。我听不懂他们说什么的时候，会用非常慢的语速再重复，如果再听不懂会用笔写下来。还是不懂的话我会打电话给日语好的朋友让我朋友帮我说，不管花多长时间他们不会显示出不耐烦。据日本的朋友说，我们作为纳税人养活着他们，他们态度好不是理所当然的么。我觉得非常震惊，但是仔细想过又觉得他说的非常有道理。但是日本非常不方便的是办事情只能工作日，周六周日从来不上班。但是工作现场可以调休这一点也正好弥补了这一点不方便。还有非常不方便的地方就是日本的快递不能邮寄到公司，只能邮到家里。但是提前不能指定时间，他们送到之后。人不在家拿不了时，会给一张不在联络票放在邮箱，拿到不在联络票再指定时间。我觉得这真是一个神奇而又变态的设定。在日本总体来说有着非常好的服务态度，不用担心食品安全问题，每天都能看到蓝天，很多细节感人泪人，也不用在意各种墙，写代码因为网络原因出现各种奇怪而又难解决的问题。但是毕竟这不是自己的家乡，会觉得不适应。也会想家人，想老婆，想孩子，也想我家那只蓝猫。</p><h1 id="我接下来的计划"><a href="#我接下来的计划" class="headerlink" title="我接下来的计划"></a>我接下来的计划</h1><p>在日本工作生活，时间越长越觉得日语不好是多么的不方便。听着别人说一口流利的日语，真的是不要太羡慕。所以接下来首要的任务就是加油学日语，然后报今年7月份的N2。如果N2能考，12月份接着考N1,万一考不过继续考N2。反正不考到N1不罢休。然后就是好好学学技术，技术是自己的饭碗所以这个当然不能丢。计划做一个独立小游戏上线推广。朋友注册了公司，帮忙做一些公司建设方面的内容。N1到手之后开始把时间转移到学英语和钢琴上，然后考一些日本政府认可的技术证书等等（高级人才签证的准备工作）。我一直觉得人活着，过一天就要有新的收获，所以每一天都在不停的学习。达到一个目标后，继续开始新的目标。比如说初中时各个假期学五笔、学PS、学装系统、电脑维修等等，这些都为我以后的工作生活带来了极大的方便 。有的时候和我朋友讲我的经历，他们总会觉得我的经历充满了传奇，非常的羡慕。但是我想说的是，每个人都是一个精彩的传奇，我被别人羡慕着同样也羡慕着别人。我也有特别多让人烦心的事情，也是一个普通的不能再普通的普通人。</p><h1 id="不会日语可以来日本工作吗"><a href="#不会日语可以来日本工作吗" class="headerlink" title="不会日语可以来日本工作吗"></a>不会日语可以来日本工作吗</h1><p>完全可以，因为众所周知，日本是一个少子化相当严重的国家，而IT行业缺人尤为严重。只要会一点点技术，基本上都不会找不到工作。不过工资不会太高，一般会在25万左右。但是想在日本长期生活，建议尽最大努力提长自己的日语能力。哪怕来了日语才开始记50音图都没关系，但是一直要快点把日语学好，因为这关系到自己的待遇和生活质量。谁都不想出去了只买自己知道的东西，找不到东西不知道怎么给店员说。有人可能会反驳，很多店都有中国店员，甚至有很多日本人也在在学中文。但是在日本这个国家生活，只想靠中文生活是不是有点说不过去。</p><h1 id="以上"><a href="#以上" class="headerlink" title="以上"></a>以上</h1><p>断断续续天马行空的写了些乱七八糟的东西。想看的朋友将就着看，如果有什么问题想了解我没有提到的欢迎留言，我会适当补充内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来日本也差不多有2个月啦，这2个月时间也一直没有更新博客。主要是因为换了新环境很多事情需要做，很多地方需要适应，所以没时间也没法静下心来写写博客记录一下生活。现在终于有时间坐下来记录一下在日本的生活日常。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://xiaomo.info/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://xiaomo.info/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>docker应用</title>
    <link href="https://xiaomo.info/2018/aboutDockerUse/"/>
    <id>https://xiaomo.info/2018/aboutDockerUse/</id>
    <published>2018-06-22T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>docker是一个简化部署的容器,使用docker不仅能够降低性能消耗，而且方便部署工作，在互联网企业中使用十分普遍。<br><a id="more"></a></p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ol><li>解决了运行环境不一致的问题。</li><li>docker隔离了运行环境，对同一台服务器上运行的其他应用不会产生任何影响。</li><li>docker可伸缩的部署服务减少了资源的浪费和运维的人工成本。</li></ol><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://www.docker.com/get-docker" target="_blank" rel="noopener">https://www.docker.com/get-docker</a></p><h1 id="网易镜像"><a href="#网易镜像" class="headerlink" title="网易镜像"></a>网易镜像</h1><p><a href="https://c.163yun.com/hub#/m/home/" target="_blank" rel="noopener">https://c.163yun.com/hub#/m/home/</a></p><h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><h2 id="center-os"><a href="#center-os" class="headerlink" title="center os"></a>center os</h2><p>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。通过 uname -r 命令查看你当前的内核版本<br><code>uname -r</code></p><h3 id="yum安装docker"><a href="#yum安装docker" class="headerlink" title="yum安装docker"></a>yum安装docker</h3><p><code>yum -y install docker-io</code><br>运行docker<br><code>systemctl start docker</code><br>测试<br><code>docker run hello-world</code></p><h3 id="脚本安装docker"><a href="#脚本安装docker" class="headerlink" title="脚本安装docker"></a>脚本安装docker</h3><p>更新系统组件<br><code>sudo yum update</code><br>执行 Docker 安装脚本<br><code>curl -fsSL https://get.docker.com/ | sh</code><br>启动docker<br><code>sudo service docker start</code><br>验证 docker 是否安装成功并在容器中执行一个测试的镜像。<br><code>sudo docker run hello-world</code><br><code>docker ps</code></p><h3 id="docker镜像加速"><a href="#docker镜像加速" class="headerlink" title="docker镜像加速"></a>docker镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a href="http://hub-mirror.c.163.com。新版的" target="_blank" rel="noopener">http://hub-mirror.c.163.com。新版的</a> Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。<br>请在该配置文件中加入（没有该文件的话，请先建一个）：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"http://hub-mirror.c.163.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mac-os"><a href="#mac-os" class="headerlink" title="mac os"></a>mac os</h2><p>一个命令搞定<br><code>brew cask install docker</code></p><h3 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a href="http://hub-mirror.c.163.com。" target="_blank" rel="noopener">http://hub-mirror.c.163.com。</a><br>在任务栏点击 Docker for mac 应用图标 -&gt; Preferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址即可。修改完成之后，点击 Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。</p><h1 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h1><ol><li>查看应用容器 <code>docker ps</code></li><li>启动一个容器 <code>docker run -d -p 5000:5000 training/webapp python app.py</code></li><li>查看应用日志 <code>docker logs -f 7a38a1ad55c6</code></li><li>查看应用程序容器的进程 <code>docker top 镜像名</code></li><li>检查应用程序 <code>docker inspect 镜像名</code></li><li>停止应用容器 <code>docker stop 镜像名</code></li><li>移除应用容器 <code>docker rm 镜像名</code></li><li>查看镜像列表 <code>docker image</code></li><li>获取一个新镜像 <code>docker pull image:tag</code></li><li>查找镜像 <code>docker search httpd</code></li><li>构建镜像 <code>docker build -t image:tag .</code></li><li>设置镜像tag <code>docker tag 860c279d2fec image:tag</code></li></ol><h1 id="docker学习资源"><a href="#docker学习资源" class="headerlink" title="docker学习资源"></a>docker学习资源</h1><p><a href="http://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">http://www.runoob.com/docker/docker-command-manual.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker是一个简化部署的容器,使用docker不仅能够降低性能消耗，而且方便部署工作，在互联网企业中使用十分普遍。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="https://xiaomo.info/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="容器" scheme="https://xiaomo.info/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-Java中ArrayList、LinkedList和Vector的联系与区别</title>
    <link href="https://xiaomo.info/2018/jdkSourceCodeReadArrayListAndLinkedArrayList/"/>
    <id>https://xiaomo.info/2018/jdkSourceCodeReadArrayListAndLinkedArrayList/</id>
    <published>2018-06-11T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>毫无疑问，List是一种非常基础的数据结构，翻译过来就是列表。正如它的名字所示，List表示的是一个有序(插入顺序)的元素序列。在Java的集合框架中，List是作为顶级接口Collection的直接子类接口存在，因此，List分支是集合框架中最简单、最常用的分支。<br><a id="more"></a></p><h1 id="List概述"><a href="#List概述" class="headerlink" title="List概述"></a>List概述</h1><p>List分支作为集合框架中最简单、最常用的分支，其在集合框架中的位置可以直接参看下图：<br><img src="https://image.xiaomo.info/blog/linkedArraylist.jpg" alt></p><p>仔细观察和分析此图，你会发现JDK中对于List接口的实现由三种类型：ArrayList、Vector 和 LinkedList。当我们谈论List的时候，我们可以用它与Set来做比较，集合框架中的Set代表一群无序和唯一的元素集合。<br>仔细观察上图可知，集合框架中的List接口具有多达三个实现类。由继承机制可知，它们在很多方面都是非常相似的，比如有序、用法等。它们之间最大的区别是它们的内部实现方式和细节，不同的实现方式和细节造就了它们之间巨大的性能差异和用法差异。</p><ol><li>ArrayList 是Java语言对于动态数组的一个实现。当不断地添加新的元素到ArrayList集合中时，该集合的底层数组的长度就会动态的增长，以便能容纳新添加的元素。至于ArrayList的底层数组长度的动态增长策略，在不同的JDK实现和版本中是不同的，最常见的策略是新增 %50，具体请参看源码。正因为ArrayList的底层实现是数组，其带来的一个特性是：它的元素可以通过 getter(index) 和 setter(index) 方法直接访问，而且性能特别好。</li><li>LinkedList 的底层实现是基于 双向队列(double linked list)。熟悉数据结构的读者应该可以猜到：LinkedList 对于新增和删除元素的操作在性能上远远优于 ArrayList。但是，它的缺点在于：其 getter(index) 方法和 setter(index) 方法的性能很差，时间复杂度是 O(n)。</li><li>Vector 与 ArrayList 唯一的区别是：它是同步的(synchronized)，线程安全。</li></ol><h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><ol><li>对于ArrayList，add/remove的时间复杂度是 O(n)；但在尾部操作是 O(1) 。</li><li>对于LinkedList，add/remove的时间复杂度是 O(n)；但在尾部和头部操作的是 O(1) 。</li></ol><h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><p>为了实际测验三种List的add、get和remove的性能，我们可以使用如下的代码片段：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">arrayList.<span class="keyword">add</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"duration : "</span> + duration);</span><br></pre></td></tr></table></figure><p>此处只给出测验ArrayList的add操作的代码，但是测验LinkedList和其他操作的代码是类似，读者可自行修改代码进行测验。测验的结果表明：<br>在add和remove操作时，LinkedList的性能远优于ArrayList。在get操作时，ArrayList的性能优于LinkedList。经过性能对比和性能的测试，我们可以总结出如何在它们之间做出选择。通常使用ArrayList，但是LinkedList在如下场景时更合适：</p><ol><li>随机访问集合元素的次数不是很频繁。</li><li>对集合有大量的add/remove操作需求。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对比Vector和ArrayList，如果程序本身就是线程安全的，为了更好的性能，应该选择ArrayList。当添加新的元素到集合时，Vector和ArrayList都需要更多的空间来存储新元素，但是它们的增长策略是不一样的：Vector的增长幅度是 100%；ArrayList的增长幅度是 50%。对于LinkdedList而言，其不仅实现了List接口，还实现了Queue接口，这个Queue接口给LinkdedList带来了更多的访问和操作元素的方法，比如 offer(), peek(), poll() 等。<br>对于ArrayList而言，如果使用不含参数的构造函数新建一个ArrayList对象，该对象的起始大小是比较小的，只有10。我们都知道对象的动态增长导致的底层数组重写分配和复制是一个非常耗时的操作。所以，对于可以预估ArrayList大小的应用场景，应该指定ArrayList对象的初始大小，从而提供性能。</p><h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="http://www.tiantianbianma.com/java-arraylist-linkedlist-vector.html/" target="_blank" rel="noopener">Java中ArrayList、LinkedList和Vector的联系与区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毫无疑问，List是一种非常基础的数据结构，翻译过来就是列表。正如它的名字所示，List表示的是一个有序(插入顺序)的元素序列。在Java的集合框架中，List是作为顶级接口Collection的直接子类接口存在，因此，List分支是集合框架中最简单、最常用的分支。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-String,StringBuffer,StringBuilder</title>
    <link href="https://xiaomo.info/2018/jdkSourceCodeReadStringDifferent/"/>
    <id>https://xiaomo.info/2018/jdkSourceCodeReadStringDifferent/</id>
    <published>2018-06-09T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>String,StringBuilder以及StringBuffer这三个类之间有什么区别?<br><a id="more"></a></p><p>这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。</p><p>首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String<br>String最慢的原因：<br>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。以下面一段代码为例：</p><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span>=<span class="string">"abc"</span>;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line"><span class="built_in">str</span>=<span class="built_in">str</span>+<span class="string">"de"</span>;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br></pre></td></tr></table></figure><p>　如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。另外，有时候我们会这样对字符串进行赋值</p><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span>=<span class="string">"abc"</span>+<span class="string">"de"</span>;</span><br><span class="line">StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder().<span class="built_in">append</span>(<span class="string">"abc"</span>).<span class="built_in">append</span>(<span class="string">"de"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(stringBuilder.toString());</span><br></pre></td></tr></table></figure><p>这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和<code>String str=&quot;abcde&quot;;</code>是完全一样的，所以会很快，而如果写成下面这种形式</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">String <span class="attribute">str1</span>=<span class="string">"abc"</span>;</span><br><span class="line">String <span class="attribute">str2</span>=<span class="string">"de"</span>;</span><br><span class="line">String <span class="attribute">str</span>=str1+str2;</span><br></pre></td></tr></table></figure><p>那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。</p><ol start="2"><li><p>再来说线程安全<br>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的<br>如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p></li><li><p>总结一下<br>String：适用于少量的字符串操作的情况<br>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况<br>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p></li></ol><h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="https://www.cnblogs.com/su-feng/p/6659064.html" target="_blank" rel="noopener">Java中的String，StringBuilder，StringBuffer三者的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;String,StringBuilder以及StringBuffer这三个类之间有什么区别?&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-类的初始化顺序</title>
    <link href="https://xiaomo.info/2018/jdkSourceCodeReadClassInitOrder/"/>
    <id>https://xiaomo.info/2018/jdkSourceCodeReadClassInitOrder/</id>
    <published>2018-06-09T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>大家在去参加面试的时候，经常会遇到这样的考题：给你两个类的代码，它们之间是继承的关系，每个类里只有构造器方法和一些变量，构造器里可能还有一段代码对变量值进行了某种运算，另外还有一些将变量值输出到控制台的代码，然后让我们判断输出的结果。这实际上是在考查我们对于继承情况下类的初始化顺序的了解<br><a id="more"></a><br>我们大家都知道，对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）&gt;（变量、初始化块）&gt;构造器。我们也可以通过下面的测试代码来验证这一点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialOrderTest</span> </span>&#123;</span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;</span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="keyword">public</span> String field = <span class="string">"变量"</span>;</span><br><span class="line"><span class="comment">// 静态初始化块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(staticField);</span><br><span class="line">    System.out.println(<span class="string">"静态初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化块</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(field);</span><br><span class="line">    System.out.println(<span class="string">"初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"构造器"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> InitialOrderTest();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上代码，我们会得到如下的输出结果：</p><ol><li>静态变量</li><li>静态初始化块</li><li>变量</li><li>初始化块</li><li>构造器</li></ol><p>这与上文中说的完全符合。那么对于继承情况下又会怎样呢？我们仍然以一段测试代码来获取最终结果:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String p_StaticField = <span class="string">"父类--静态变量"</span>;</span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="keyword">public</span> String p_Field = <span class="string">"父类--变量"</span>;</span><br><span class="line"><span class="comment">// 静态初始化块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(p_StaticField);</span><br><span class="line">    System.out.println(<span class="string">"父类--静态初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化块</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(p_Field);</span><br><span class="line">    System.out.println(<span class="string">"父类--初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println(<span class="string">"父类--构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String s_StaticField = <span class="string">"子类--静态变量"</span>;</span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="keyword">public</span> String s_Field = <span class="string">"子类--变量"</span>;</span><br><span class="line"><span class="comment">// 静态初始化块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(s_StaticField);</span><br><span class="line">    System.out.println(<span class="string">"子类--静态初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化块</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(s_Field);</span><br><span class="line">    System.out.println(<span class="string">"子类--初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"子类--构造器"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SubClass();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下上面的代码，结果马上呈现在我们的眼前：</p><ol><li>父类–静态变量</li><li>父类–静态初始化块</li><li>子类–静态变量</li><li>子类–静态初始化块</li><li>父类–变量</li><li>父类–初始化块</li><li>父类–构造器</li><li>子类–变量</li><li>子类–初始化块</li><li>子类–构造器</li></ol><p>现在，结果已经不言自明了。大家可能会注意到一点，那就是，并不是父类完全初始化完毕后才进行子类的初始化，实际上子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了。<br>那么对于静态变量和静态初始化块之间、变量和初始化块之间的先后顺序又是怎样呢？是否静态变量总是先于静态初始化块，变量总是先于初始化块就被初始化了呢？实际上这取决于它们在类中出现的先后顺序。我们以静态变量和静态初始化块为例来进行说明。</p><p>同样，我们还是写一个类来进行测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOrder</span> </span>&#123;</span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TestA a = <span class="keyword">new</span> TestA();</span><br><span class="line"><span class="comment">// 静态初始化块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"静态初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TestB b = <span class="keyword">new</span> TestB();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> TestOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test--A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test--B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码，会得到如下的结果：</p><ol><li>Test–A</li><li>静态初始化块</li><li>Test–B</li></ol><p>大家可以随意改变变量a、变量b以及静态初始化块的前后位置，就会发现输出结果随着它们在类中出现的前后顺序而改变，这就说明静态变量和静态初始化块是依照他们在类中的定义顺序进行初始化的。同样，变量和初始化块也遵循这个规律。了解了继承情况下类的初始化顺序之后，如何判断最终输出结果就迎刃而解了</p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>转载自 臧圩人 <a href="http://zangweiren.javaeye.com" target="_blank" rel="noopener">http://zangweiren.javaeye.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家在去参加面试的时候，经常会遇到这样的考题：给你两个类的代码，它们之间是继承的关系，每个类里只有构造器方法和一些变量，构造器里可能还有一段代码对变量值进行了某种运算，另外还有一些将变量值输出到控制台的代码，然后让我们判断输出的结果。这实际上是在考查我们对于继承情况下类的初始化顺序的了解&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-创建对象</title>
    <link href="https://xiaomo.info/2018/jdkSourceCodeReadCreateObject/"/>
    <id>https://xiaomo.info/2018/jdkSourceCodeReadCreateObject/</id>
    <published>2018-06-09T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p><code>String str=new String(&quot;abc&quot;);</code>到底创建了几个对象？相信大家对这此并不陌生，答案也是众所周知的，2个。接下来我们就从这道题展开，一起回顾一下与创建String对象相关的一些JAVA知识。<br><a id="more"></a></p><h1 id="String-str-new-String-quot-abc-quot"><a href="#String-str-new-String-quot-abc-quot" class="headerlink" title="String str=new String(&quot;abc&quot;);"></a><code>String str=new String(&quot;abc&quot;);</code></h1><p>我们可以把上面这行代码分成String str、=、”abc”和new String()四部分来看待。String str只是定义了一个名为str的String类型的变量，因此它并没有创建对象；=是对变量str进行初始化，将某个对象的引用（或者叫句柄）赋值给它，显然也没有创建对象；现在只剩下new String(“abc”)了。那么，new String(“abc”)为什么又能被看成”abc”和new String()呢？我们来看一下被我们调用了的String的构造器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//other code ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家都知道，我们常用的创建一个类的实例（对象）的方法有以下两种：</p><ol><li>使用new创建对象。</li><li>调用Class类的newInstance方法，利用反射机制创建对象。<br>我们正是使用new调用了String类的上面那个构造器方法创建了一个对象，并将它的引用赋值给了str变量。同时我们注意到，被调用的构造器方法接受的参数也是一个String对象，这个对象正是”abc”。由此我们又要引入另外一种创建String对象的方式的讨论——引号内包含文本。这种方式是String特有的，并且它与new的方式存在很大区别</li></ol><h1 id="String-str-quot-abc-quot"><a href="#String-str-quot-abc-quot" class="headerlink" title="String str=&quot;abc&quot;;"></a><code>String str=&quot;abc&quot;;</code></h1><p>毫无疑问，这行代码创建了一个String对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    String a=<span class="string">"abc"</span>;</span><br><span class="line">    String b=<span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这里呢？答案还是一个。</p><p><code>String a=&quot;ab&quot;+&quot;cd&quot;;</code><br>再看看这里呢？答案仍是一个。有点奇怪吗？说到这里，我们就需要引入对字符串池相关知识的回顾了。</p><p>在JAVA虚拟机（JVM）中存在着一个字符串池，其中保存着很多String对象，并且可以被共享使用，因此它提高了效率。由于String类是final的，它的值一经创建就不可改变，因此我们不用担心String对象共享而带来程序的混乱。字符串池由String类维护，我们可以调用intern()方法来访问字符串池。我们再回头看看String a=”abc”;，这行代码被执行的时候，JAVA虚拟机首先在字符串池中查找是否已经存在了值为”abc”的这么一个对象，它的判断依据是String类equals(Object obj)方法的返回值。如果有，则不再创建新的对象，直接返回已存在对象的引用；如果没有，则先创建这个对象，然后把它加入到字符串池中，再将它的引用返回。因此，我们不难理解前面三个例子中头两个例子为什么是这个答案了。<br>对于第三个例子：<br>String a=”ab”+”cd”;<br>由于常量的值在编译的时候就被确定了。在这里，”ab”和”cd”都是常量，因此变量a的值在编译时就可以确定。</p><p>这行代码编译后的效果等同于：<br>String a=”abcd”;<br>因此这里只创建了一个对象”abcd”，并且它被保存在字符串池里了。现在问题又来了，是不是所有经过“+”连接后得到的字符串都会被添加到字符串池中呢？我们都知道“==”</p><p>可以用来比较两个变量，它有以下两种情况：</p><ol><li>如果比较的是两个基本类型（char，byte，short，int，long，float，double，boolean），则是判断它们的值是否相等。</li><li>如果表较的是两个对象变量，则是判断它们的引用是否指向同一个对象。</li></ol><p>下面我们就用“==”来做几个测试。为了便于说明，我们把指向字符串池中已经存在的对象也视为该对象被加入了字符串池：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String a = <span class="string">"ab"</span>;<span class="comment">// 创建了一个对象，并加入字符串池中</span></span><br><span class="line">System.out.println(<span class="string">"String a = \"ab\";"</span>);</span><br><span class="line">String b = <span class="string">"cd"</span>;<span class="comment">// 创建了一个对象，并加入字符串池中</span></span><br><span class="line">System.out.println(<span class="string">"String b = \"cd\";"</span>);</span><br><span class="line">String c = <span class="string">"abcd"</span>;<span class="comment">// 创建了一个对象，并加入字符串池中</span></span><br><span class="line">String d = <span class="string">"ab"</span> + <span class="string">"cd"</span>;</span><br><span class="line"><span class="comment">// 如果d和c指向了同一个对象，则说明d也被加入了字符串池</span></span><br><span class="line"><span class="keyword">if</span> (d == c) &#123;</span><br><span class="line">    System.out.println(<span class="string">"\"ab\"+\"cd\" 创建的对象 \"加入了\" 字符串池中"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果d和c没有指向了同一个对象，则说明d没有被加入字符串池</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"\"ab\"+\"cd\" 创建的对象 \"没加入\" 字符串池中"</span>);</span><br><span class="line">&#125;</span><br><span class="line">String e = a + <span class="string">"cd"</span>;</span><br><span class="line"><span class="comment">// 如果e和c指向了同一个对象，则说明e也被加入了字符串池</span></span><br><span class="line"><span class="keyword">if</span> (e == c) &#123;</span><br><span class="line">    System.out.println(<span class="string">" a +\"cd\" 创建的对象 \"加入了\" 字符串池中"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果e和c没有指向了同一个对象，则说明e没有被加入字符串池</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">" a +\"cd\" 创建的对象 \"没加入\" 字符串池中"</span>);</span><br><span class="line">&#125;</span><br><span class="line">String f = <span class="string">"ab"</span> + b;</span><br><span class="line"><span class="comment">// 如果f和c指向了同一个对象，则说明f也被加入了字符串池</span></span><br><span class="line"><span class="keyword">if</span> (f == c) &#123;</span><br><span class="line">    System.out.println(<span class="string">"\"ab\"+ b 创建的对象 \"加入了\" 字符串池中"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果f和c没有指向了同一个对象，则说明f没有被加入字符串池</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"\"ab\"+ b 创建的对象 \"没加入\" 字符串池中"</span>);</span><br><span class="line">&#125;</span><br><span class="line">String g = a + b;</span><br><span class="line"><span class="comment">// 如果g和c指向了同一个对象，则说明g也被加入了字符串池</span></span><br><span class="line"><span class="keyword">if</span> (g == c) &#123;</span><br><span class="line">    System.out.println(<span class="string">" a + b 创建的对象 \"加入了\" 字符串池中"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果g和c没有指向了同一个对象，则说明g没有被加入字符串池</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">" a + b 创建的对象 \"没加入\" 字符串池中"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><ol><li>String a = “ab”;</li><li>String b = “cd”;</li><li>“ab”+”cd” 创建的对象 “加入了” 字符串池中</li><li>a +”cd” 创建的对象 “没加入” 字符串池中</li><li>“ab”+ b 创建的对象 “没加入” 字符串池中</li><li>a + b 创建的对象 “没加入” 字符串池中</li></ol><p>从上面的结果中我们不难看出，只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中，对此我们不再赘述</p><p>但是有一种情况需要引起我们的注意。请看下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringStaticTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 常量A</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String A = <span class="string">"ab"</span>;</span><br><span class="line">    <span class="comment">// 常量B</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String B = <span class="string">"cd"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将两个常量用+连接对s进行初始化</span></span><br><span class="line">    String s = A + B;</span><br><span class="line">    String t = <span class="string">"abcd"</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">        System.out.println(<span class="string">"s等于t，它们是同一个对象"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"s不等于t，它们不是同一个对象"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的运行结果如下：</p><ul><li>s等于t，它们是同一个对象</li></ul><p>这又是为什么呢？原因是这样的，对于常量来讲，它的值是固定的，因此在编译期就能被确定了，而变量的值只有到运行时才能被确定，因为这个变量可以被不同的方法调用，从而可能引起值的改变。在上面的例子中，A和B都是常量，值是固定的，因此s的值也是固定的，它在类被编译时就已经确定了。也就是说：</p><p><code>String s=A+B;</code> 等同于<code>String s=&quot;ab&quot;+&quot;cd&quot;;</code></p><p>我对上面的例子稍加改变看看会出现什么情况：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringStaticTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 常量A</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String A;</span><br><span class="line">    <span class="comment">// 常量B</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String B;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    A = <span class="string">"ab"</span>;</span><br><span class="line">    B = <span class="string">"cd"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将两个常量用+连接对s进行初始化</span></span><br><span class="line">    String s = A + B;</span><br><span class="line">    String t = <span class="string">"abcd"</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">        System.out.println(<span class="string">"s等于t，它们是同一个对象"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"s不等于t，它们不是同一个对象"</span>);</span><br><span class="line">     &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的运行结果是这样：</p><ul><li>s不等于t，它们不是同一个对象<br>只是做了一点改动，结果就和刚刚的例子恰好相反。我们再来分析一下。A和B虽然被定义为常量（只能被赋值一次），但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。由于字符串池中对象的共享能够带来效率的提高，因此我们提倡大家用引号包含文本的方式来创建String对象，实际上这也是我们在编程中常采用的。<br>接下来我们再来看看intern()方法，它的定义如下：<br><code>public native String intern();</code></li></ul><p>这是一个本地方法。在调用这个方法时，JAVA虚拟机首先检查字符串池中是否已经存在与该对象值相等对象存在，如果有则返回字符串池中对象的引用；如果没有，则先在字符串池中创建一个相同值的String对象，然后再将它的引用返回。</p><p>我们来看这段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringInternTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用char数组来初始化a，避免在a被创建之前字符串池中已经存在了值为"abcd"的对象</span></span><br><span class="line">    String a = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span> &#125;);</span><br><span class="line">    String b = a.intern();</span><br><span class="line">    <span class="keyword">if</span> (b == a) &#123;</span><br><span class="line">        System.out.println(<span class="string">"b被加入了字符串池中，没有新建对象"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"b没被加入字符串池中，新建了对象"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>b没被加入字符串池中，新建了对象。如果String类的intern()方法在没有找到相同值的对象时，是把当前对象加入字符串池中，然后返回它的引用的话，那么b和a指向的就是同一个对象；否则b指向的对象就是JAVA虚拟机在字符串池中新建的，只是它的值与a相同罢了。上面这段代码的运行结果恰恰印证了这一点。最后我们再来说说String对象在JAVA虚拟机（JVM）中的存储，以及字符串池与堆（heap）和栈（stack）的关系。我们首先回顾一下堆和栈的区别：</p><p>• 栈（stack）：主要保存基本类型（或者叫内置类型）（char、byte、short、int、long、float、double、boolean）和对象的引用，数据可以共享，速度仅次于寄存器（register），快于堆。<br>• 堆（heap）：用于存储对象。</p><p>我们查看String类的源码就会发现，它有一个value属性，保存着String对象的值，类型是char[]，这也正说明了字符串就是字符的序列。当执行String a=”abc”;时，JAVA虚拟机会在栈中创建三个char型的值’a’、’b’和’c’，然后在堆中创建一个String对象，它的值（value）是刚才在栈中创建的三个char型值组成的数组{‘a’,’b’,’c’}，最后这个新创建的String对象会被添加到字符串池中。如果我们接着执行String b=new String(“abc”);代码，由于”abc”已经被创建并保存于字符串池中，因此JAVA虚拟机只会在堆中新创建一个String对象，但是它的值（value）是共享前一行代码执行时在栈中创建的三个char型值值’a’、’b’和’c’。说到这里，我们对于篇首提出的String str=new String(“abc”)为什么是创建了两个对象这个问题就已经相当明了了</p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>转载自 臧圩人 <a href="http://zangweiren.javaeye.com" target="_blank" rel="noopener">http://zangweiren.javaeye.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;String str=new String(&amp;quot;abc&amp;quot;);&lt;/code&gt;到底创建了几个对象？相信大家对这此并不陌生，答案也是众所周知的，2个。接下来我们就从这道题展开，一起回顾一下与创建String对象相关的一些JAVA知识。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-ThreadLocal</title>
    <link href="https://xiaomo.info/2018/jdkSourceCodeReadThreadLocal/"/>
    <id>https://xiaomo.info/2018/jdkSourceCodeReadThreadLocal/</id>
    <published>2018-06-02T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>这个类提供本地线程变量。不同于一般的变量，这些变量在他们各自的线程里通过 get、set 访问一个它自己的变量，这是一个独立初始化的变量副本。在一个类中，ThreadLocal 实例一般是 private static 的，期望和一个线程关联状态（如 userId，transactionId 等）。简单地说，就是此类提供了线程的本地变量，线程修改本地变量不互相影响。<br><a id="more"></a></p><p>举个例子，下面的类给每个线程生成一个唯一的标识。一个线程 id 在第一次调用 ThreadId.get() 被赋值，并且在后续的调用上保持不变。</p><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadId</span> </span>&#123;  </span><br><span class="line">       <span class="comment">// Atomic integer containing the next thread ID to be assigned  </span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextId = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// Thread local 变量保存着每个线程的ID  </span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =  </span><br><span class="line">           <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;  </span><br><span class="line">               <span class="meta">@Override</span> <span class="keyword">protected</span> <span class="function">Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                   <span class="function"><span class="keyword">return</span> nextId.<span class="title">getAndIncrement</span><span class="params">()</span></span>;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;;  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 返回当前线程的唯一ID，如果没有值的话先赋值  </span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">           <span class="function"><span class="keyword">return</span> threadId.<span class="title">get</span><span class="params">()</span></span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要线程还存活并且 ThreadLocal 实例可访问，那么每个线程持有一个确定的引用指向本地的变量副本，当线程消失，它的本地变量副本将会被GC（除非还被其他对象引用）。</p><h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/** </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>执行结果： </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-0,5,main]---------count=0 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-0,5,main]---------count=1 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-0,5,main]---------count=2 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-0,5,main]---------count=3 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-0,5,main]---------count=4 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-2,5,main]---------count=0 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-2,5,main]---------count=1 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-2,5,main]---------count=2 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-1,5,main]---------count=0 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-2,5,main]---------count=3 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-2,5,main]---------count=4 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-1,5,main]---------count=1 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-1,5,main]---------count=2 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-1,5,main]---------count=3 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread[Thread-1,5,main]---------count=4 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>可以看出线程的变量更新没有相互影响 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Created by hzzhuyibin on 2017/3/14. </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    private <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; count = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;  </span><br><span class="line">        public Integer initialValue() &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;  </span><br><span class="line">  </span><br><span class="line">        NewThread thread1 = <span class="keyword">new</span> NewThread(count);  </span><br><span class="line">        NewThread thread2 = <span class="keyword">new</span> NewThread(count);  </span><br><span class="line">        NewThread thread3 = <span class="keyword">new</span> NewThread(count);  </span><br><span class="line">  </span><br><span class="line">        thread1.start();  </span><br><span class="line">        thread3.start();  </span><br><span class="line">        thread2.start();  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </span><br><span class="line">        ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">null</span>;  </span><br><span class="line">  </span><br><span class="line">        public NewThread(ThreadLocal&lt;Integer&gt; threadLocal) &#123;  </span><br><span class="line">            <span class="keyword">this</span>.threadLocal = threadLocal;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        public <span class="keyword">void</span> run() &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;  </span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"---------count="</span> + threadLocal.<span class="keyword">get</span>());  </span><br><span class="line">                threadLocal.<span class="keyword">set</span>(threadLocal.<span class="keyword">get</span>() + <span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>ThreadLocal 的数据结构：实线表示强引用，虚线表示弱引用<br>每个 Thread 维护一个ThreadLocalMap 映射 table，映射 table 的 key 是 ThreadLocal 实例，value 就是线程存独立的变量副本的地方。<br>为什么这么设计，而不是由 ThreadLocal 来维护一个以 Thread 为 key 的映射呢？原因如下：</p><ol><li>减小 Entry 数组大小：ThreadLocal 数量多，还是 Thread 的数量多，显而易见，使用 ThreadLocal 来当 key 可以减少 Entry 数量</li><li>减小内存占用：当 Thread 消亡，对 Thread 实例不在引用，则 GC 后就会清除相关数据</li></ol><p><img src="https://image.xiaomo.info/blog/threadLocal.png" alt></p><ol><li>先看字段含义</li></ol><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** ThreadLocals 依赖每个线程的线性嗅探哈希映射到每个线程(Thread.threadLocals and inheritableThreadLocals)。 </span></span><br><span class="line"><span class="comment"> * ThreadLocal 对象作为 key，通过 threadLocalHashCode 来搜索。这是一个定制化的减少冲突的哈希码（只在 ThreadLocalMaps 有用）， </span></span><br><span class="line"><span class="comment"> * 其中连续构造的ThreadLocals由相同的线程使用，在较不常见的情况下保持良好行为。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 生成下一个 Hash Code。原子更新。从零开始。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =  </span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     *连续生成的散列码之间的差异 - 将隐式顺序线程本地ID转换为二次幂表的近似最优扩展的乘法散列值。 </span></span><br><span class="line"><span class="comment">     *简单来说就是偏移量，offetset </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回下一个 Hash 值 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextHashCode() &#123;  </span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>主要方法：</li></ol><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**   返回当前线程的线程本地变量值。这个方法将会在线程第一次通过 get() 访问变量的时候调用， </span></span><br><span class="line"><span class="comment">     * 除非这个线程之前调用过 set() 那么 initialValue() 才不会被调用。通常，这个方法只会被调用一次, </span></span><br><span class="line"><span class="comment">     * 但是它在 get() 后调用 remove()，能被再次调用。 </span></span><br><span class="line"><span class="comment">     * 这里实现是简单返回 null，如果想赋其他值需要重写这个方法。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span>(<span class="params"></span>)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>核心方法 get() 相关内容：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 返回当前线程的本地变量副本值。如果这个变量没有值，则返回 initialValue() 初始化的值 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">public</span> T <span class="keyword">get</span>() &#123;  </span><br><span class="line">    Thread t = Thread.currentThread();  </span><br><span class="line">    <span class="comment">// ThreadLocalMap 是一个为了保存线程本地变量定制化的 hash map。  </span></span><br><span class="line">    ThreadLocalMap map = getMap(t);  </span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;  </span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);  </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="meta">@SuppressWarnings(<span class="meta-string">"unchecked"</span>)</span>  </span><br><span class="line">            T result = (T)e.value;  </span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> setInitialValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 getMap(Thread t)：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**   获取和ThreadLocal相关的 map。在 InheritableThreadLocal中重写 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread 类中的代码：这里可以看到是 Thread 持有 ThreadLocal.ThreadLocalMap 引用</p><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 与此线程有关的ThreadLocal值。 此 map 由ThreadLocal类维护。 */</span>  </span><br><span class="line">dLocal.ThreadLocalMap <span class="attr">threadLocals</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>其中的 map.getEntry(this)：</p><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 获取和key关联的Entry。 此方法本身仅处理快速路径：直接命中现有键。 </span></span><br><span class="line"><span class="comment"> *  这是为了最大限度地提高直接命中的性能，部分通过使这种方法很容易嵌入。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> Entry getEntry(ThreadLocal&lt;?&gt; <span class="built_in">key</span>) &#123;  </span><br><span class="line">    <span class="built_in">int</span> i = <span class="built_in">key</span>.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);  </span><br><span class="line">    Entry e = table[i];  </span><br><span class="line">    <span class="comment">// 命中 hash slot  </span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.<span class="built_in">get</span>() == <span class="built_in">key</span>)  </span><br><span class="line">        <span class="keyword">return</span> e;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="comment">// 如果在 hash slot 里面没有直接查到就进入这个方法  </span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(<span class="built_in">key</span>, i, e);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 如果在 hash slot 里面没有直接查到就进入这个方法 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; <span class="built_in">key</span>, <span class="built_in">int</span> i, Entry e) &#123;  </span><br><span class="line">    Entry[] tab = table;  </span><br><span class="line">    <span class="built_in">int</span> len = tab.length;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.<span class="built_in">get</span>();  </span><br><span class="line">        <span class="keyword">if</span> (k == <span class="built_in">key</span>)  </span><br><span class="line">            <span class="keyword">return</span> e;  </span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) <span class="comment">// 清理无用 entry  </span></span><br><span class="line">            expungeStaleEntry(i);  </span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 可以看出这里使用开放定址法来解决哈希冲突  </span></span><br><span class="line">            i = nextIndex(i, len);  </span><br><span class="line">        e = tab[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 核心方法 set() 相关内容：</p><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 设置 key 的 value </span></span><br><span class="line"><span class="comment"> * 这里不使用 get() 方法中的快速路径，因为新建和更新的比例差不多， </span></span><br><span class="line"><span class="comment"> * 使用快速路径查找失败率很高 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="built_in">set</span>(ThreadLocal&lt;?&gt; <span class="built_in">key</span>, <span class="keyword">Object</span> value) &#123;  </span><br><span class="line">  </span><br><span class="line">    Entry[] tab = table;  </span><br><span class="line">    <span class="built_in">int</span> len = tab.length;  </span><br><span class="line">    <span class="built_in">int</span> i = <span class="built_in">key</span>.threadLocalHashCode &amp; (len<span class="number">-1</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 开发地址法，遍历查找  </span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];  </span><br><span class="line">         e != <span class="keyword">null</span>;  </span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;  </span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.<span class="built_in">get</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (k == <span class="built_in">key</span>) &#123;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// key 为 null，说明 ThreadLocal 实例已被回收，  </span></span><br><span class="line">            <span class="comment">// 所以这里的 value 可以被覆盖。减少内存泄露的可能  </span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            replaceStaleEntry(<span class="built_in">key</span>, value, i);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 没有找到 Entry 则新建一个  </span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(<span class="built_in">key</span>, value);  </span><br><span class="line">    <span class="built_in">int</span> sz = ++<span class="built_in">size</span>;  </span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)  </span><br><span class="line">        rehash();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p><a href="https://blog.csdn.net/wenniuwuren" target="_blank" rel="noopener">wenniuwuren</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个类提供本地线程变量。不同于一般的变量，这些变量在他们各自的线程里通过 get、set 访问一个它自己的变量，这是一个独立初始化的变量副本。在一个类中，ThreadLocal 实例一般是 private static 的，期望和一个线程关联状态（如 userId，transactionId 等）。简单地说，就是此类提供了线程的本地变量，线程修改本地变量不互相影响。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-ConcurrentHashMap</title>
    <link href="https://xiaomo.info/2018/jdkSourceCodeReadConcurrentHashMap/"/>
    <id>https://xiaomo.info/2018/jdkSourceCodeReadConcurrentHashMap/</id>
    <published>2018-06-02T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>ConcurrentHashMap 是将锁的范围细化来实现高效并发的。 基本策略是将数据结构分为一个一个 Segment（每一个都是一个并发可读的 hash table， 即分段锁）作为一个并发单元。 为了减少开销， 除了一处 Segment 是在构造器初始化的， 其他都延迟初始化（详见 ensureSegment）。 并使用 volatile 关键字来保证 Segment 延迟初始化的可见性问题。 </p><p>HashMap 不是线程安全的， 故多线程情况下会出现 infinit loop。 HashTable 是线程安全的， 但是是用全局锁来保障， 效率很低。 所以 Doug Lea 并发专家研发了高效并发的 ConcurrentHashMap 来应对并发情况下的情景。 阅读本文前最好先看： <a href="https://blog.xiaomo.info/2018/jdkSourceCodeReadMemoryActor/" target="_blank" rel="noopener">Java内存模型</a> 和 <a href="https://blog.xiaomo.info/2018/jdkSourceCodeReadAtomicInteger/" target="_blank" rel="noopener">AtomicInteger 分析</a>。<br><a id="more"></a></p><h1 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h1><ol><li><p>哈希算法<br>是一种将任意内容的输入转换成相同长度输出的加密方式，其输出被称为哈希值。</p></li><li><p>哈希表<br>根据设定的哈希函数H(key)和处理冲突方法将一组关键字映象到一个有限的地址区间上，并以关键字在地址区间中的象作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。</p></li></ol><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><img src="https://image.xiaomo.info/blog/c1.png" alt></p><p>抽象结构图<br><img src="https://image.xiaomo.info/blog/c2.png" alt></p><p>从上述类图和抽象结构图可以看出 ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 继承(Generalization)了可重入锁ReentrantLock，HashEntry 用于存储键值对数据。一个 ConcurrentHashMap 里 contains-a (Composition) 一个 Segment []，Segment 的结构和 HashMap 类似，是一种数组和链表结构， 一个 Segment 里 has-a (Aggregation)一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 锁定一个 HashEntry 数组里的元素, 当对 HashEntry 数组的数据进行 put 等修改操作时，必须先获得它对应的 Segment 锁。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>内部类 Segment 类：<br>Segment 维护着条目列表状态一致性， 所以可以实现无锁读。 在表超出 threshold 进行 resize 的时候， 复制节点， 所以在做 resize 修改操作的时候， 还可以进行读操作（在旧 list 读）。 本类里只有变化操作的方法才需要加锁， 变化的方法利用一系列忙等控制来处理资源争用， 例如 scanAndLock 和 scanAndLockForPut 。 那些遍历去查找节点的 tryLocks() 方法， 主要是用来吸收 cached 不命中(在 hash tables 经常出现)， 这样后续获取锁的遍历操作效率将会有不小提升。 我们可能不是真的需要使用找到的数据， 因为重新获得数据还需要加锁来保证更新操作的一致性， 但他们会更快地进行重定位。 此外，  scanAndLockForPut 特地创建新数据用于没有数据被找到的 put 方法。</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在准备锁住 segment 操作前最大的 tryLock() 次数。 多核情况下， 在定位 nodes 时使用 64 次最大值维持缓存  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =  </span><br><span class="line">    <span class="keyword">Runtime</span>.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * The per-segment table. 数据访问通过 </span></span><br><span class="line"><span class="comment"> * entryAt/setEntryAt 提供的 volatile 语义来保证可见性. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * sengment 内 hash entry 元素个数 , 之所以在每个 Segment 对象中包含一个计数器，而不是在 ConcurrentHashMap 中使用全局的计数器，是为了避免出现“热点域”而影响 ConcurrentHashMap 的并发性。 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">count</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 在 segment 中可变操作总数, 即更新次数 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 当超过threshold 时候，  table 再哈希 </span></span><br><span class="line"><span class="comment"> * (The value of this field is always &lt;tt&gt;(int)(capacity * </span></span><br><span class="line"><span class="comment"> * loadFactor)&lt;/tt&gt;.) </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> threshold;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *  hash table 负载因子.  Even though this value </span></span><br><span class="line"><span class="comment"> * is same for all segments, it is replicated to avoid needing </span></span><br><span class="line"><span class="comment"> * links to outer object. </span></span><br><span class="line"><span class="comment"> * @serial </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p><code>put</code> 方法：<br>插入A， B， C后 Segment 示意图：</p><p><img src="https://image.xiaomo.info/blog/c3.png" alt></p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function">final V <span class="title">put</span>(<span class="params">K key, <span class="keyword">int</span> hash, V <span class="keyword">value</span>, boolean onlyIfAbsent</span>)</span> &#123;  </span><br><span class="line"> <span class="comment">// tryLock 一般缓存作用  </span></span><br><span class="line">HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :  </span><br><span class="line">        scanAndLockForPut(key, hash, <span class="keyword">value</span>);  </span><br><span class="line">    V oldValue;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;  </span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;  </span><br><span class="line">        <span class="comment">// 找到 bucket 位置  </span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);  </span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;  </span><br><span class="line">                K k;  </span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||  </span><br><span class="line">                    (e.hash == hash &amp;&amp; key.<span class="keyword">equals</span>(k))) &#123;  </span><br><span class="line">                    <span class="comment">// 保存旧值， 这样 get 操作就可以无锁访问正在写操作的节点  </span></span><br><span class="line">                    oldValue = e.<span class="keyword">value</span>;  </span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;  </span><br><span class="line">                        <span class="comment">// 覆盖原来的值  </span></span><br><span class="line">                        e.<span class="keyword">value</span> = <span class="keyword">value</span>;  </span><br><span class="line">                        <span class="comment">// 修改计数  </span></span><br><span class="line">                        ++modCount;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// 每次从头部插入  </span></span><br><span class="line">                e = e.next;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)  </span><br><span class="line">                    node.setNext(first);  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, <span class="keyword">value</span>, first);  </span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;  </span><br><span class="line">                <span class="comment">// 超过 threshold 则， rehash()  </span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)  </span><br><span class="line">                    rehash(node);  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                    setEntryAt(tab, index, node);  </span><br><span class="line">                ++modCount;  </span><br><span class="line">                count = c;  </span><br><span class="line">                oldValue = <span class="literal">null</span>;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="comment">// 典型的 ReentrantLock 释放锁  </span></span><br><span class="line">        unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> oldValue;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap的size操作<br>如果我们要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有Segment的put，remove和clean方法全部锁住，但是这种做法显然非常低效。 因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。</p><p>那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put , remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p><p><code>rehash()</code> 方法:  在新 table 中重新分类节点。 因为使用了 2 的幂指数扩展方式， bucket/bin 中的数据还是在原位， 即旧数据的索引位置不变或者偏移了 2 的幂指数距离。 可以重用旧节点减少不必要的节点生成。 </p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * table 大小 *2， 重新放置 HashEntry， 加入新节点 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">@SuppressWarnings(<span class="string">"unchecked"</span>)  </span><br><span class="line"><span class="keyword">private</span> void rehash(HashEntry&lt;K,V&gt; node) &#123;  </span><br><span class="line">    <span class="comment">// 保存旧值以便 get 操作遍历  </span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;  </span><br><span class="line">    int oldCapacity = oldTable.length;  </span><br><span class="line">    int <span class="keyword">new</span><span class="type">Capacity</span> = oldCapacity &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    threshold = (int)(<span class="keyword">new</span><span class="type">Capacity</span> * loadFactor);  </span><br><span class="line">    HashEntry&lt;K,V&gt;[] <span class="keyword">new</span><span class="type">Table</span> =  </span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> <span class="type">HashEntry</span>[<span class="keyword">new</span><span class="type">Capacity</span>];  </span><br><span class="line">    int sizeMask = <span class="keyword">new</span><span class="type">Capacity</span> - <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;  </span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];  </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;  </span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;  </span><br><span class="line">            int idx = e.hash &amp; sizeMask;  </span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)   <span class="comment">//  单节点链表  </span></span><br><span class="line">                <span class="keyword">new</span><span class="type">Table</span>[idx] = e;  </span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 重用在同一个 slot 的连续序列  </span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;  </span><br><span class="line">                int lastIdx = idx;  </span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;  </span><br><span class="line">                     last != <span class="literal">null</span>;  </span><br><span class="line">                     last = last.next) &#123;  </span><br><span class="line">                    int k = last.hash &amp; sizeMask;  </span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;  </span><br><span class="line">                        lastIdx = k;  </span><br><span class="line">                        lastRun = last;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">new</span><span class="type">Table</span>[lastIdx] = lastRun;  </span><br><span class="line">                <span class="comment">// Clone remaining nodes  </span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;  </span><br><span class="line">                    V v = p.value;  </span><br><span class="line">                    int h = p.hash;  </span><br><span class="line">                    int k = h &amp; sizeMask;  </span><br><span class="line">                    HashEntry&lt;K,V&gt; n = <span class="keyword">new</span><span class="type">Table</span>[k];  </span><br><span class="line">                    <span class="keyword">new</span><span class="type">Table</span>[k] = <span class="keyword">new</span> <span class="type">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    int nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node  </span></span><br><span class="line">    node.setNext(<span class="keyword">new</span><span class="type">Table</span>[nodeIndex]);  </span><br><span class="line">    <span class="keyword">new</span><span class="type">Table</span>[nodeIndex] = node;  </span><br><span class="line">    table = <span class="keyword">new</span><span class="type">Table</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类 <code>HashEntry</code>：链表结构</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> HashEntry&lt;K,V&gt; &#123;  </span><br><span class="line">    <span class="comment">// final 保证不变性， 即为线程安全的字段  </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  </span><br><span class="line">    <span class="keyword">final</span> K key;  </span><br><span class="line">    <span class="comment">// 根据 volatile 写永远先于读操作的 happens-before 原则来保证获取到都是最新值  </span></span><br><span class="line">    <span class="keyword">volatile</span> V value;  </span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; <span class="keyword">next</span>;  </span><br><span class="line">  </span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; <span class="keyword">next</span>) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.hash = hash;  </span><br><span class="line">        <span class="keyword">this</span>.key = key;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">next</span> = <span class="keyword">next</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 使用 volatile 写语义设置 next </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> setNext(HashEntry&lt;K,V&gt; n) &#123;  </span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, n);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Unsafe mechanics  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();  </span><br><span class="line">            <span class="keyword">Class</span> k = HashEntry.<span class="keyword">class</span>;  </span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset  </span><br><span class="line">                (k.getDeclaredField(<span class="string">"next"</span>));  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcurrentHashMap 类：</code></p><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Constants -------------- */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * The default initial capacity for this table, </span></span><br><span class="line"><span class="comment"> * used when not otherwise specified in a constructor. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 本值是 HashEntry 个数与 table 数组长度的比值 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75</span>f;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 当前并发线程的使用数 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly </span></span><br><span class="line"><span class="comment"> * specified by either of the constructors with arguments.  MUST </span></span><br><span class="line"><span class="comment"> * be a power of two &lt;= 1&lt;&lt;30 to ensure that entries are indexable </span></span><br><span class="line"><span class="comment"> * using ints. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * The minimum capacity for per-segment tables.  Must be a power </span></span><br><span class="line"><span class="comment"> * of two, at least two to avoid immediate resizing on next use </span></span><br><span class="line"><span class="comment"> * after lazy construction. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * The maximum number of segments to allow; used to bound </span></span><br><span class="line"><span class="comment"> * constructor arguments. Must be power of two less than 1 &lt;&lt; 24. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>; <span class="comment">// slightly conservative  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Number of unsynchronized retries in size and containsValue </span></span><br><span class="line"><span class="comment"> * methods before resorting to locking. This is used to avoid </span></span><br><span class="line"><span class="comment"> * unbounded retries if tables undergo continuous modification </span></span><br><span class="line"><span class="comment"> * which would make it impossible to obtain an accurate result. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 索引 segments 时使用： 使用高比特位的 hash 值去选择 segment </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentMask;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Shift value for indexing within segments. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentShift;</span><br></pre></td></tr></table></figure><p>初始化 ConcurrentHashMap:<br>ConcurrentHashMap 结构图</p><p><img src="https://image.xiaomo.info/blog/c4.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,  </span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();  </span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)  </span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;  </span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments  </span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;  </span><br><span class="line">        ++sshift;  </span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;  </span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)  </span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;  </span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;  </span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)  </span><br><span class="line">        ++c;  </span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;  </span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)  </span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">// create segments and segments[0]  </span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =  </span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),  </span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);  </span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];  </span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]  </span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可知segments数组的长度size通过concurrencyLevel计算得出。为了能通过按位与的哈希算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方（power-of-two size），所以必须计算出一个是大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14，15或16，ssize都会等于16，即容器里锁的个数也是16。注意concurrencyLevel的最大大小是65535，意味着segments数组的长度最大为65536，对应的二进制是16位。</p><p>初始化segmentShift和segmentMask。这两个全局变量在定位segment时的哈希算法里需要使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与hash运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是哈希运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p><p>变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝(int)cap*loadFactor，默认情况下initialCapacity等于16，load factor等于0.75，通过运算cap等于1，threshold等于零。</p><h1 id="在jdk1-8中主要做了2方面的改进"><a href="#在jdk1-8中主要做了2方面的改进" class="headerlink" title="在jdk1.8中主要做了2方面的改进"></a>在jdk1.8中主要做了2方面的改进</h1><p>数据结构<br>1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，结构如下：<br><img src="https://image.xiaomo.info/blog/nodeArray.png" alt></p><p>只有在执行第一次put方法时才会调用initTable()初始化Node数组，实现如下：</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] <span class="keyword">tab</span>; int <span class="keyword">sc</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">sc</span> = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="keyword">sc</span>, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">                    int <span class="keyword">n</span> = (<span class="keyword">sc</span> &gt; 0) ? <span class="keyword">sc</span> : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[<span class="keyword">n</span>];</span><br><span class="line">                    <span class="keyword">table</span> = <span class="keyword">tab</span> = nt;</span><br><span class="line">                    <span class="keyword">sc</span> = <span class="keyword">n</span> - (<span class="keyword">n</span> &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl = <span class="keyword">sc</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">tab</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put实现<br>当执行put方法插入数据时，根据key的hash值，在Node数组中找到相应的位置，实现如下：</p><p>1、如果相应位置的Node还未初始化，则通过CAS插入相应的数据；</p><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = <span class="built_in">tabAt</span>(<span class="built_in">tab</span>, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="built_in">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">casTabAt</span>(<span class="built_in">tab</span>, i, <span class="built_in">null</span>, new Node&lt;K,V&gt;(hash, <span class="built_in">key</span>, value, <span class="built_in">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    binCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((ek = e.key) == <span class="built_in">key</span> ||</span><br><span class="line">             (ek != <span class="built_in">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="built_in">null</span>) &#123;</span><br><span class="line">            pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>, value, <span class="built_in">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；</p><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f instanceof TreeBin) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    binCount = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).<span class="built_in">putTreeVal</span>(hash, <span class="built_in">key</span>, value)) != <span class="built_in">null</span>) &#123;</span><br><span class="line">        oldVal = p.val;</span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">            p.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        <span class="built_in">treeifyBin</span>(<span class="built_in">tab</span>, i);</span><br><span class="line">    <span class="keyword">if</span> (oldVal != <span class="built_in">null</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</p><p>size实现<br>1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount，实现如下：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">as</span> = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">    !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">    CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">    boolean uncontended = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">as</span> == <span class="literal">null</span> || (m = <span class="keyword">as</span>.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">        (a = <span class="keyword">as</span>[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">        !(uncontended =</span><br><span class="line">          U.compareAndSwapLong(a, CELLVALUE, v = a.<span class="keyword">value</span>, v + x))) &#123;</span><br><span class="line">        fullAddCount(x, uncontended);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    s = sumCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、初始化时counterCells为空，在并发量很高时，如果存在两个线程同时执行CAS修改baseCount值，则失败的线程会继续执行方法体中的逻辑，使用CounterCell记录元素个数的变化；</p><p>2、如果CounterCell数组counterCells为空，调用fullAddCount()方法进行初始化，并插入对应的记录数，通过CAS设置cellsBusy字段，只有设置成功的线程才能初始化CounterCell数组，实现如下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == <span class="keyword">as</span> &amp;&amp;</span><br><span class="line">         U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">    boolean <span class="keyword">init</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">        <span class="keyword">if</span> (counterCells == <span class="keyword">as</span>) &#123;</span><br><span class="line">            CounterCell[] rs = new CounterCell[<span class="number">2</span>];</span><br><span class="line">            rs[h &amp; <span class="number">1</span>] = new CounterCell(x);</span><br><span class="line">            counterCells = rs;</span><br><span class="line">            <span class="keyword">init</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        cellsBusy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">init</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、如果通过CAS设置cellsBusy字段失败的话，则继续尝试通过CAS修改baseCount字段，如果修改baseCount字段成功的话，就退出循环，否则继续循环插入CounterCell对象；</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>所以在1.8中的size实现比1.7简单多，因为元素个数保存baseCount中，部分元素的变化个数保存在CounterCell数组中，实现如下：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">final <span class="keyword">long</span> <span class="title">sumCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    CounterCell[] <span class="keyword">as</span> = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">as</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">as</span>.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = <span class="keyword">as</span>[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.<span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数；</p><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p><a href="https://blog.csdn.net/wenniuwuren" target="_blank" rel="noopener">wenniuwuren</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ConcurrentHashMap 是将锁的范围细化来实现高效并发的。 基本策略是将数据结构分为一个一个 Segment（每一个都是一个并发可读的 hash table， 即分段锁）作为一个并发单元。 为了减少开销， 除了一处 Segment 是在构造器初始化的， 其他都延迟初始化（详见 ensureSegment）。 并使用 volatile 关键字来保证 Segment 延迟初始化的可见性问题。 &lt;/p&gt;
&lt;p&gt;HashMap 不是线程安全的， 故多线程情况下会出现 infinit loop。 HashTable 是线程安全的， 但是是用全局锁来保障， 效率很低。 所以 Doug Lea 并发专家研发了高效并发的 ConcurrentHashMap 来应对并发情况下的情景。 阅读本文前最好先看： &lt;a href=&quot;https://blog.xiaomo.info/2018/jdkSourceCodeReadMemoryActor/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java内存模型&lt;/a&gt; 和 &lt;a href=&quot;https://blog.xiaomo.info/2018/jdkSourceCodeReadAtomicInteger/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AtomicInteger 分析&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-深入了解IO的工作机制</title>
    <link href="https://xiaomo.info/2018/jdkSourceCodeReadIO/"/>
    <id>https://xiaomo.info/2018/jdkSourceCodeReadIO/</id>
    <published>2018-06-02T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>I/O 问题是任何编程语言都无法回避的问题，可以说 I/O 问题是整个人机交互的核心问题，因为 I/O 是机器获取和交换信息的主要渠道。在当今这个数据大爆炸时代，I/O 问题尤其突出，很容易成为一个性能瓶颈。正因如此，所以 Java 在 I/O 上也一直在做持续的优化，如从 1.4 开始引入了 NIO，提升了 I/O 的性能。<br><a id="more"></a></p><h1 id="Java-的-I-O-类库的基本架构"><a href="#Java-的-I-O-类库的基本架构" class="headerlink" title="Java 的 I/O 类库的基本架构"></a>Java 的 I/O 类库的基本架构</h1><p>Java 的 I/O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是：</p><ol><li>基于字节操作的 I/O 接口：InputStream 和 OutputStream</li><li>基于字符操作的 I/O 接口：Writer 和 Reader</li><li>基于磁盘操作的 I/O 接口：File</li><li>基于网络操作的 I/O 接口：Socket</li></ol><p>前两组主要是根据传输数据的数据格式，后两组主要是根据传输数据的方式，虽然 Socket 类并不在 java.io 包下，但是我仍然把它们划分在一起，因为我个人认为 I/O 的核心问题要么是数据格式影响 I/O 操作，要么是传输方式影响 I/O 操作，也就是将什么样的数据写到什么地方的问题，I/O 只是人与机器或者机器与机器交互的手段，除了在它们能够完成这个交互功能外，我们关注的就是如何提高它的运行效率了，而数据格式和传输方式是影响效率最关键的因素了。我们后面的分析也是基于这两个因素来展开的。</p><h1 id="基于字节的-I-O-操作接口"><a href="#基于字节的-I-O-操作接口" class="headerlink" title="基于字节的 I/O 操作接口"></a>基于字节的 I/O 操作接口</h1><p>基于字节的 I/O 操作接口输入和输出分别是：InputStream 和 OutputStream，InputStream 输入流的类继承层次如下图所示：<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image002.png" alt></p><p>输入流根据数据类型和操作方式又被划分成若干个子类，每个子类分别处理不同操作类型，OutputStream 输出流的类层次结构也是类似，如下图所示：<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image004.png" alt><br>这里就不详细解释每个子类如何使用了，如果不清楚的话可以参考一下 JDK 的 API 说明文档，这里只想说明两点，一个是操作数据的方式是可以组合使用的，如这样组合使用<br><code>OutputStream out = new BufferedOutputStream(new ObjectOutputStream(new FileOutputStream(&quot;fileName&quot;))；</code><br>还有一点是流最终写到什么地方必须要指定，要么是写到磁盘要么是写到网络中，其实从上面的类图中我们发现，写网络实际上也是写文件，只不过写网络还有一步需要处理就是底层操作系统再将数据传送到其它地方而不是本地磁盘。关于网络 I/O 和磁盘 I/O 我们将在后面详细介绍。</p><h1 id="基于字符的-I-O-操作接口"><a href="#基于字符的-I-O-操作接口" class="headerlink" title="基于字符的 I/O 操作接口"></a>基于字符的 I/O 操作接口</h1><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，但是为啥有操作字符的 I/O 接口呢？这是因为我们的程序中通常操作的数据都是以字符形式，为了操作方便当然要提供一个直接写字符的 I/O 接口，如此而已。我们知道字符到字节必须要经过编码转换，而这个编码又非常耗时，而且还会经常出现乱码问题，所以 I/O 的编码问题经常是让人头疼的问题。关于 I/O 编码问题请参考另一篇文章 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/" target="_blank" rel="noopener">《深入分析Java中的中文编码问题》</a>。<br>下图是写字符的 I/O 操作接口涉及到的类，Writer 类提供了一个抽象方法 write(char cbuf[], int off, int len) 由子类去实现。<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image006.png" alt></p><p>读字符的操作接口也有类似的类结构，如下图所示：<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image008.png" alt><br>读字符的操作接口中也是 int read(char cbuf[], int off, int len)，返回读到的 n 个字节数，不管是 Writer 还是 Reader 类它们都只定义了读取或写入的数据字符的方式，也就是怎么写或读，但是并没有规定数据要写到哪去，写到哪去就是我们后面要讨论的基于磁盘和网络的工作机制。</p><h1 id="字节与字符的转化接口"><a href="#字节与字符的转化接口" class="headerlink" title="字节与字符的转化接口"></a>字节与字符的转化接口</h1><p>另外数据持久化或网络传输都是以字节进行的，所以必须要有字符到字节或字节到字符的转化。字符到字节需要转化，其中读的转化过程如下图所示：<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image011.jpg" alt><br>InputStreamReader 类是字节到字符的转化桥梁，InputStream 到 Reader 的过程要指定编码字符集，否则将采用操作系统默认字符集，很可能会出现乱码问题。StreamDecoder 正是完成字节到字符的解码的实现类。也就是当你用如下方式读取一个文件时：</p><p>读取文件<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">   StringBuffer <span class="built_in">str</span> = <span class="keyword">new</span> StringBuffer(); </span><br><span class="line">   <span class="built_in">char</span>[] buf = <span class="keyword">new</span> <span class="built_in">char</span>[<span class="number">1024</span>]; </span><br><span class="line">   FileReader f = <span class="keyword">new</span> FileReader(<span class="string">"file"</span>); </span><br><span class="line">   <span class="keyword">while</span>(f.read(buf)&gt;<span class="number">0</span>)&#123; </span><br><span class="line">       <span class="built_in">str</span>.<span class="built_in">append</span>(buf); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="built_in">str</span>.toString(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>FileReader 类就是按照上面的工作方式读取文件的，FileReader 是继承了 InputStreamReader 类，实际上是读取文件流，然后通过 StreamDecoder 解码成 char，只不过这里的解码字符集是默认字符集。<br>写入也是类似的过程如下图所示：<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image013.jpg" alt><br>通过 OutputStreamWriter 类完成，字符到字节的编码过程，由 StreamEncoder 完成编码过程。</p><h1 id="磁盘-I-O-工作机制"><a href="#磁盘-I-O-工作机制" class="headerlink" title="磁盘 I/O 工作机制"></a>磁盘 I/O 工作机制</h1><p>前面介绍了基本的 Java I/O 的操作接口，这些接口主要定义了如何操作数据，以及介绍了操作两种数据结构：字节和字符的方式。还有一个关键问题就是数据写到何处，其中一个主要方式就是将数据持久化到物理磁盘，下面将介绍如何将数据持久化到物理磁盘的过程。</p><p>我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多。</p><p>何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。</p><p>下面以清单 1 的程序为例，介绍下如何从磁盘读取一段文本字符。如下图所示：</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image015.jpg" alt></p><p>当传入一个文件路径，将会根据这个路径创建一个 File 对象来标识这个文件，然后将会根据这个 File 对象创建真正读取文件的操作对象，这时将会真正创建一个关联真实存在的磁盘文件的文件描述符 FileDescriptor，通过这个对象可以直接控制这个磁盘文件。由于我们需要读取的是字符格式，所以需要 StreamDecoder 类将 byte 解码为 char 格式，至于如何从磁盘驱动器上读取一段数据，由操作系统帮我们完成。至于操作系统是如何将数据持久化到磁盘以及如何建立数据结构需要根据当前操作系统使用何种文件系统来回答，至于文件系统的相关细节可以参考另外的文章。</p><h1 id="Java-Socket-的工作机制"><a href="#Java-Socket-的工作机制" class="headerlink" title="Java Socket 的工作机制"></a>Java Socket 的工作机制</h1><p>Socket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。</p><p>下图是典型的基于 Socket 的通信的场景：<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image017.jpg" alt><br>主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。</p><h1 id="建立通信链路"><a href="#建立通信链路" class="headerlink" title="建立通信链路"></a>建立通信链路</h1><p>当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。</p><p>与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。</p><h1 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h1><p>传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。<br>当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。</p><h1 id="NIO-的工作方式"><a href="#NIO-的工作方式" class="headerlink" title="NIO 的工作方式"></a>NIO 的工作方式</h1><h2 id="BIO-带来的挑战"><a href="#BIO-带来的挑战" class="headerlink" title="BIO 带来的挑战"></a>BIO 带来的挑战</h2><p>BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时都有可能会阻塞。一旦有线程阻塞将会失去 CPU 的使用权，这在当前的大规模访问量和有性能要求情况下是不能接受的。虽然当前的网络 I/O 有一些解决办法，如一个客户端一个处理线程，出现阻塞时只是一个线程阻塞而不会影响其它线程工作，还有为了减少系统线程的开销，采用线程池的办法来减少线程创建和回收的成本，但是有一些使用场景仍然是无法解决的。如当前一些需要大量 HTTP 长连接的情况，像淘宝现在使用的 Web 旺旺项目，服务端需要同时保持几百万的 HTTP 连接，但是并不是每时每刻这些连接都在传输数据，这种情况下不可能同时创建这么多线程来保持连接。即使线程的数量不是问题，仍然有一些问题还是无法避免的。如这种情况，我们想给某些客户端更高的服务优先级，很难通过设计线程的优先级来完成，另外一种情况是，我们需要让每个客户端的请求在服务端可能需要访问一些竞争资源，由于这些客户端是在不同线程中，因此需要同步，而往往要实现这些同步操作要远远比用单线程复杂很多。以上这些情况都说明，我们需要另外一种新的 I/O 操作方式。</p><h2 id="NIO-的工作机制"><a href="#NIO-的工作机制" class="headerlink" title="NIO 的工作机制"></a>NIO 的工作机制</h2><p>我们先看一下 NIO 涉及到的关联类图，如下：<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image019.jpg" alt></p><p>上图中有两个关键类：Channel 和 Selector，它们是 NIO 中两个核心概念。我们还用前面的城市交通工具来继续比喻 NIO 的工作方式，这里的 Channel 要比 Socket 更加具体，它可以比作为某种具体的交通工具，如汽车或是高铁等，而 Selector 可以比作为一个车站的车辆运行调度系统，它将负责监控每辆车的当前运行状态：是已经出战还是在路上等等，也就是它可以轮询每个 Channel 的状态。这里还有一个 Buffer 类，它也比 Stream 更加具体化，我们可以将它比作为车上的座位，Channel 是汽车的话就是汽车上的座位，高铁上就是高铁上的座位，它始终是一个具体的概念，与 Stream 不同。Stream 只能代表是一个座位，至于是什么座位由你自己去想象，也就是你在去上车之前并不知道，这个车上是否还有没有座位了，也不知道上的是什么车，因为你并不能选择，这些信息都已经被封装在了运输工具（Socket）里面了，对你是透明的。NIO 引入了 Channel、Buffer 和 Selector 就是想把这些信息具体化，让程序员有机会控制它们，如：当我们调用 write() 往 SendQ 写数据时，当一次写的数据超过 SendQ 长度是需要按照 SendQ 的长度进行分割，这个过程中需要有将用户空间数据和内核地址空间进行切换，而这个切换不是你可以控制的。而在 Buffer 中我们可以控制 Buffer 的 capacity，并且是否扩容以及如何扩容都可以控制。</p><p>理解了这些概念后我们看一下，实际上它们是如何工作的，下面是典型的一段 NIO 代码：</p><p> NIO 工作代码示例</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">public</span> void <span class="keyword">selector() </span>throws IOException &#123;</span><br><span class="line">        <span class="keyword">ByteBuffer </span><span class="keyword">buffer </span>= <span class="keyword">ByteBuffer.allocate(1024);</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">Selector </span><span class="keyword">selector </span>= <span class="keyword">Selector.open();</span></span><br><span class="line"><span class="keyword"> </span>       ServerSocketChannel ssc = ServerSocketChannel.open()<span class="comment">;</span></span><br><span class="line">        ssc.configureBlocking(false)<span class="comment">;//设置为非阻塞方式</span></span><br><span class="line">        ssc.socket().<span class="keyword">bind(new </span>InetSocketAddress(<span class="number">8080</span>))<span class="comment">;</span></span><br><span class="line">        ssc.register(<span class="keyword">selector, </span><span class="keyword">SelectionKey.OP_ACCEPT);//注册监听的事件</span></span><br><span class="line"><span class="keyword"> </span>       <span class="meta">while</span> (true) &#123;</span><br><span class="line">            Set <span class="keyword">selectedKeys </span>= <span class="keyword">selector.selectedKeys();//取得所有key集合</span></span><br><span class="line"><span class="keyword"> </span>           <span class="keyword">Iterator </span><span class="keyword">it </span>= <span class="keyword">selectedKeys.iterator();</span></span><br><span class="line"><span class="keyword"> </span>           <span class="meta">while</span> (<span class="keyword">it.hasNext()) </span>&#123;</span><br><span class="line">                <span class="keyword">SelectionKey </span>key = (<span class="keyword">SelectionKey) </span><span class="keyword">it.next();</span></span><br><span class="line"><span class="keyword"> </span>               <span class="meta">if</span> ((key.readyOps() &amp; <span class="keyword">SelectionKey.OP_ACCEPT) </span>== <span class="keyword">SelectionKey.OP_ACCEPT) </span>&#123;</span><br><span class="line">                    ServerSocketChannel ssChannel = (ServerSocketChannel) key.channel()<span class="comment">;</span></span><br><span class="line">                 SocketChannel sc = ssChannel.accept()<span class="comment">;//接受到服务端的请求</span></span><br><span class="line">                    sc.configureBlocking(false)<span class="comment">;</span></span><br><span class="line">                    sc.register(<span class="keyword">selector, </span><span class="keyword">SelectionKey.OP_READ);</span></span><br><span class="line"><span class="keyword"> </span>                   <span class="keyword">it.remove();</span></span><br><span class="line"><span class="keyword"> </span>               &#125; <span class="meta">else</span> <span class="meta">if</span> </span><br><span class="line">                ((key.readyOps() &amp; <span class="keyword">SelectionKey.OP_READ) </span>== <span class="keyword">SelectionKey.OP_READ) </span>&#123;</span><br><span class="line">                    SocketChannel sc = (SocketChannel) key.channel()<span class="comment">;</span></span><br><span class="line">                    <span class="meta">while</span> (true) &#123;</span><br><span class="line">                        <span class="keyword">buffer.clear();</span></span><br><span class="line"><span class="keyword"> </span>                       int n = sc.read(<span class="keyword">buffer);//读取数据</span></span><br><span class="line"><span class="keyword"> </span>                       <span class="meta">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>                       &#125;</span><br><span class="line">                        <span class="keyword">buffer.flip();</span></span><br><span class="line"><span class="keyword"> </span>                   &#125;</span><br><span class="line">                    <span class="keyword">it.remove();</span></span><br><span class="line"><span class="keyword"> </span>               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 Selector 的静态工厂创建一个选择器，创建一个服务端的 Channel 绑定到一个 Socket 对象，并把这个通信信道注册到选择器上，把这个通信信道设置为非阻塞模式。然后就可以调用 Selector 的 selectedKeys 方法来检查已经注册在这个选择器上的所有通信信道是否有需要的事件发生，如果有某个事件发生时，将会返回所有的 SelectionKey，通过这个对象 Channel 方法就可以取得这个通信信道对象从而可以读取通信的数据，而这里读取的数据是 Buffer，这个 Buffer 是我们可以控制的缓冲器。</p><p>在上面的这段程序中，是将 Server 端的监听连接请求的事件和处理请求的事件放在一个线程中，但是在实际应用中，我们通常会把它们放在两个线程中，一个线程专门负责监听客户端的连接请求，而且是阻塞方式执行的；另外一个线程专门来处理请求，这个专门处理请求的线程才会真正采用 NIO 的方式，像 Web 服务器 Tomcat 和 Jetty 都是这个处理方式，关于 Tomcat 和 Jetty 的 NIO 处理方式可以参考文章《 Jetty 的工作原理和与 Tomcat 的比较》。</p><p>下图是描述了基于 NIO 工作方式的 Socket 请求的处理过程：<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image021.jpg" alt><br>上图中的 Selector 可以同时监听一组通信信道（Channel）上的 I/O 状态，前提是这个 Selector 要已经注册到这些通信信道中。选择器 Selector 可以调用 select() 方法检查已经注册的通信信道上的是否有 I/O 已经准备好，如果没有至少一个信道 I/O 状态有变化，那么 select 方法会阻塞等待或在超时时间后会返回 0。上图中如果有多个信道有数据，那么将会将这些数据分配到对应的数据 Buffer 中。所以关键的地方是有一个线程来处理所有连接的数据交互，每个连接的数据交互都不是阻塞方式，所以可以同时处理大量的连接请求。</p><h2 id="Buffer-的工作方式"><a href="#Buffer-的工作方式" class="headerlink" title="Buffer 的工作方式"></a>Buffer 的工作方式</h2><p>上面介绍了 Selector 将检测到有通信信道 I/O 有数据传输时，通过 select() 取得 SocketChannel，将数据读取或写入 Buffer 缓冲区。下面讨论一下 Buffer 如何接受和写出数据？</p><p>Buffer 可以简单的理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态，也就是有四个索引。如下表所示：</p><p>Buffer 中的参数项<br><img src="https://image.xiaomo.info/blog/buffer.png" alt></p><p>在实际操作数据时它们有如下关系图：</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image023.jpg" alt></p><p>我们通过 ByteBuffer.allocate(11) 方法创建一个 11 个 byte 的数组缓冲区，初始状态如上图所示，position 的位置为 0，capacity 和 limit 默认都是数组长度。当我们写入 5 个字节时位置变化如下图所示：</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image025.jpg" alt></p><p> 这时我们需要将缓冲区的 5 个字节数据写入 Channel 通信信道，所以我们需要调用 byteBuffer.flip() 方法，数组的状态又发生如下变化：<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image027.jpg" alt> </p><p>这时底层操作系统就可以从缓冲区中正确读取这 5 个字节数据发送出去了。在下一次写数据之前我们在调一下 clear() 方法。缓冲区的索引状态又回到初始位置。</p><p>这里还要说明一下 mark，当我们调用 mark() 时，它将记录当前 position 的前一个位置，当我们调用 reset 时，position 将恢复 mark 记录下来的值。</p><p>还有一点需要说明，通过 Channel 获取的 I/O 数据首先要经过操作系统的 Socket 缓冲区再将数据复制到 Buffer 中，这个的操作系统缓冲区就是底层的 TCP 协议关联的 RecvQ 或者 SendQ 队列，从操作系统缓冲区到用户缓冲区复制数据比较耗性能，Buffer 提供了另外一种直接操作操作系统缓冲区的的方式即 ByteBuffer.allocateDirector(size)，这个方法返回的 byteBuffer 就是与底层存储空间关联的缓冲区，它的操作方式与 linux2.4 内核的 sendfile 操作方式类似。</p><h1 id="I-O-调优"><a href="#I-O-调优" class="headerlink" title="I/O 调优"></a>I/O 调优</h1><p>下面就磁盘 I/O 和网络 I/O 的一些常用的优化技巧进行总结如下：</p><h2 id="磁盘-I-O-优化"><a href="#磁盘-I-O-优化" class="headerlink" title="磁盘 I/O 优化"></a>磁盘 I/O 优化</h2><p>性能检测</p><p>我们的应用程序通常都需要访问磁盘读取数据，而磁盘 I/O 通常都很耗时，我们要判断 I/O 是否是一个瓶颈，我们有一些参数指标可以参考：</p><p>如我们可以压力测试应用程序看系统的 I/O wait 指标是否正常，例如测试机器有 4 个 CPU，那么理想的 I/O wait 参数不应该超过 25%，如果超过 25% 的话，I/O 很可能成为应用程序的性能瓶颈。Linux 操作系统下可以通过 iostat 命令查看。</p><p>通常我们在判断 I/O 性能时还会看另外一个参数就是 IOPS，我们应用程序需要最低的 IOPS 是多少，而我们的磁盘的 IOPS 能不能达到我们的要求。每个磁盘的 IOPS 通常是在一个范围内，这和存储在磁盘的数据块的大小和访问方式也有关。但是主要是由磁盘的转速决定的，磁盘的转速越高磁盘的 IOPS 也越高。</p><p>现在为了提高磁盘 I/O 的性能，通常采用一种叫 RAID 的技术，就是将不同的磁盘组合起来来提高 I/O 性能，目前有多种 RAID 技术，每种 RAID 技术对 I/O 性能提升会有不同，可以用一个 RAID 因子来代表，磁盘的读写吞吐量可以通过 iostat 命令来获取，于是我们可以计算出一个理论的 IOPS 值，计算公式如下所以：</p><p>( 磁盘数 <em> 每块磁盘的 IOPS)/( 磁盘读的吞吐量 +RAID 因子 </em> 磁盘写的吞吐量 )=IOPS</p><p>RAID 策略<br><a href="https://image.xiaomo.info/blog/raid.png" target="_blank" rel="noopener"></a></p><h2 id="网络-I-O-优化"><a href="#网络-I-O-优化" class="headerlink" title="网络 I/O 优化"></a>网络 I/O 优化</h2><p>网络 I/O 优化通常有一些基本处理原则：</p><ol><li>一个是减少网络交互的次数：要减少网络交互的次数通常我们在需要网络交互的两端会设置缓存，比如 Oracle 的 JDBC 驱动程序，就提供了对查询的 SQL 结果的缓存，在客户端和数据库端都有，可以有效的减少对数据库的访问。关于 Oracle JDBC 的内存管理可以参考《 Oracle JDBC 内存管理》。除了设置缓存还有一个办法是，合并访问请求：如在查询数据库时，我们要查 10 个 id，我可以每次查一个 id，也可以一次查 10 个 id。再比如在访问一个页面时通过会有多个 js 或 css 的文件，我们可以将多个 js 文件合并在一个 HTTP 链接中，每个文件用逗号隔开，然后发送到后端 Web 服务器根据这个 URL 链接，再拆分出各个文件，然后打包再一并发回给前端浏览器。这些都是常用的减少网络 I/O 的办法。</li><li>减少网络传输数据量的大小：减少网络数据量的办法通常是将数据压缩后再传输，如 HTTP 请求中，通常 Web 服务器将请求的 Web 页面 gzip 压缩后在传输给浏览器。还有就是通过设计简单的协议，尽量通过读取协议头来获取有用的价值信息。比如在代理程序设计时，有 4 层代理和 7 层代理都是来尽量避免要读取整个通信数据来取得需要的信息。</li><li>尽量减少编码：通常在网络 I/O 中数据传输都是以字节形式的，也就是通常要序列化。但是我们发送要传输的数据都是字符形式的，从字符到字节必须编码。但是这个编码过程是比较耗时的，所以在要经过网络 I/O 传输时，尽量直接以字节形式发送。也就是尽量提前将字符转化为字节，或者减少字符到字节的转化过程。</li><li>根据应用场景设计合适的交互方式：所谓的交互场景主要包括同步与异步阻塞与非阻塞方式，下面将详细介绍。</li></ol><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。而异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。我们可以用打电话和发短信来很好的比喻同步与异步操作。</p><p>在设计到 IO 处理时通常都会遇到一个是同步还是异步的处理方式的选择问题。因为同步与异步的 I/O 处理方式对调用者的影响很大，在数据库产品中都会遇到这个问题。因为 I/O 操作通常是一个非常耗时的操作，在一个任务序列中 I/O 通常都是性能瓶颈。但是同步与异步的处理方式对程序的可靠性影响非常大，同步能够保证程序的可靠性，而异步可以提升程序的性能，必须在可靠性和性能之间做个平衡，没有完美的解决办法。</p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞与非阻塞主要是从 CPU 的消耗上来说的，阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作。虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的 CPU 使用时间能不能补偿系统的切换成本需要好好评估。</p><h2 id="两种的方式的组合"><a href="#两种的方式的组合" class="headerlink" title="两种的方式的组合"></a>两种的方式的组合</h2><p>组合的方式可以由四种，分别是：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞，这四种方式都对 I/O 性能有影响。下面给出分析，并有一些常用的设计用例参考。</p><p> 四种组合方式<br> <a href="https://image.xiaomo.info/blog/combineMethod.png" target="_blank" rel="noopener"></a><br> 虽然异步和非阻塞能够提升 I/O 的性能，但是也会带来一些额外的性能成本，例如会增加线程数量从而增加 CPU 的消耗，同时也会导致程序设计的复杂度上升。如果设计的不合理的话反而会导致性能下降。在实际设计时要根据应用场景综合评估一下。</p><p> 下面举一些异步和阻塞的操作实例：</p><p> 在 Cassandra 中要查询数据通常会往多个数据节点发送查询命令，但是要检查每个节点返回数据的完整性，所以需要一个异步查询同步结果的应用场景，部分代码如下：</p><p> 异步查询同步结果<br> <figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">AsyncResult</span> <span class="title">implements</span> <span class="title">IAsyncResult</span>&#123; </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">byte</span>[] result_; </span><br><span class="line">   <span class="keyword">private</span> AtomicBoolean done_ = <span class="keyword">new</span> AtomicBoolean(<span class="literal">false</span>); </span><br><span class="line">   <span class="keyword">private</span> Lock lock_ = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line">   <span class="keyword">private</span> Condition condition_; </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> startTime_; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AsyncResult</span>(<span class="params"></span>)</span>&#123;        </span><br><span class="line">       condition_ = lock_.newCondition();<span class="comment">// 创建一个锁</span></span><br><span class="line">       startTime_ = System.currentTimeMillis(); </span><br><span class="line">   &#125;    </span><br><span class="line"><span class="comment">/*** 检查需要的数据是否已经返回，如果没有返回阻塞 */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">get</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">       lock_.<span class="keyword">lock</span>(); </span><br><span class="line">       <span class="keyword">try</span>&#123; </span><br><span class="line">           <span class="keyword">if</span> (!done_.<span class="keyword">get</span>())&#123;condition_.<span class="keyword">await</span>();&#125; </span><br><span class="line">       &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123; </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(ex); </span><br><span class="line">       &#125;<span class="keyword">finally</span>&#123;lock_.unlock();&#125; </span><br><span class="line">       <span class="keyword">return</span> result_; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*** 检查需要的数据是否已经返回 */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> boolean <span class="title">isDone</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> done_.<span class="keyword">get</span>();&#125; </span><br><span class="line"><span class="comment">/*** 检查在指定的时间内需要的数据是否已经返回，如果没有返回抛出超时异常 */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">get</span>(<span class="params"><span class="keyword">long</span> timeout, TimeUnit tu</span>) throws TimeoutException</span>&#123; </span><br><span class="line">       lock_.<span class="keyword">lock</span>(); </span><br><span class="line">       <span class="keyword">try</span>&#123;            boolean bVal = <span class="literal">true</span>; </span><br><span class="line">           <span class="keyword">try</span>&#123; </span><br><span class="line">               <span class="keyword">if</span> ( !done_.<span class="keyword">get</span>() )&#123; </span><br><span class="line">          <span class="keyword">long</span> overall_timeout = timeout - (System.currentTimeMillis() - startTime_); </span><br><span class="line">                   <span class="keyword">if</span>(overall_timeout &gt; <span class="number">0</span>)<span class="comment">// 设置等待超时的时间</span></span><br><span class="line">                       bVal = condition_.<span class="keyword">await</span>(overall_timeout, TimeUnit.MILLISECONDS); </span><br><span class="line">                   <span class="keyword">else</span> bVal = <span class="literal">false</span>; </span><br><span class="line">               &#125; </span><br><span class="line">           &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123; </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(ex); </span><br><span class="line">           &#125; </span><br><span class="line">           <span class="keyword">if</span> ( !bVal &amp;&amp; !done_.<span class="keyword">get</span>() )&#123;<span class="comment">// 抛出超时异常</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"Operation timed out."</span>); </span><br><span class="line">           &#125; </span><br><span class="line">       &#125;<span class="keyword">finally</span>&#123;lock_.unlock();      &#125; </span><br><span class="line">       <span class="keyword">return</span> result_; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*** 该函数拱另外一个线程设置要返回的数据，并唤醒在阻塞的线程 */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">result</span>(<span class="params">Message response</span>)</span>&#123;        </span><br><span class="line">       <span class="keyword">try</span>&#123; </span><br><span class="line">           lock_.<span class="keyword">lock</span>(); </span><br><span class="line">           <span class="keyword">if</span> ( !done_.<span class="keyword">get</span>() )&#123;                </span><br><span class="line">               result_ = response.getMessageBody();<span class="comment">// 设置返回的数据</span></span><br><span class="line">               done_.<span class="keyword">set</span>(<span class="literal">true</span>); </span><br><span class="line">               condition_.signal();<span class="comment">// 唤醒阻塞的线程</span></span><br><span class="line">           &#125; </span><br><span class="line">       &#125;<span class="keyword">finally</span>&#123;lock_.unlock();&#125;        </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文阐述的内容较多，从 Java 基本 I/O 类库结构开始说起，主要介绍了磁盘 I/O 和网络 I/O 的基本工作方式，最后介绍了关于 I/O 调优的一些方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I/O 问题是任何编程语言都无法回避的问题，可以说 I/O 问题是整个人机交互的核心问题，因为 I/O 是机器获取和交换信息的主要渠道。在当今这个数据大爆炸时代，I/O 问题尤其突出，很容易成为一个性能瓶颈。正因如此，所以 Java 在 I/O 上也一直在做持续的优化，如从 1.4 开始引入了 NIO，提升了 I/O 的性能。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-AtomicInteger</title>
    <link href="https://xiaomo.info/2018/jdkSourceCodeReadAtomicInteger/"/>
    <id>https://xiaomo.info/2018/jdkSourceCodeReadAtomicInteger/</id>
    <published>2018-06-02T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 里面提供的以 Atomic* 开头的类基本原理都是一致的， 都是借助了底层硬件级别的 Lock 来实现原子操作的。 本文以 AtomicInteger 为例进行讲述， 其他的类似。阅读本文前建议先阅读基础篇：<a href="https://blog.xiaomo.info/2018/jdkSourceCodeReadMemoryActor/" target="_blank" rel="noopener">Java内存模型</a><br><a id="more"></a></p><h1 id="处理器原子操作：-3种加锁方式"><a href="#处理器原子操作：-3种加锁方式" class="headerlink" title="处理器原子操作： 3种加锁方式"></a>处理器原子操作： 3种加锁方式</h1><p>关于 CPU 的锁有如下 3 种：</p><ol><li><p>处理器自动保证基本内存操作的原子性<br>首先处理器会自动保证基本的内存操作的原子性。 处理器保证从系统内存当中读取或者写入一个字节是原子的， 意思是当一个处理器读取一个字节时， 其他处理器不能访问这个字节的内存地址。 奔腾 6 和最新的处理器能自动保证单处理器对同一个缓存行里进行 16/32/64 位的操作是原子的， 但是复杂的内存操作处理器不能自动保证其原子性， 比如跨总线宽度， 跨多个缓存行， 跨页表的访问。 但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。 </p></li><li><p>使用总线锁保证原子性（开销大）<br>如果多个处理器同时对共享变量进行读改写（i++ 就是经典的读改写操作）操作， 那么共享变量就会被多个处理器同时进行操作， 这样读改写操作就不是原子的， 操作完之后共享变量的值会和期望的不一致， 举个例子：如果 i=1,我们进行两次 i++ 操作，我们期望的结果是 3，但是有可能结果是 2 。如下图<br>原因是有可能多个处理器同时从各自的缓存中读取变量i， 分别进行加一操作， 然后分别写入系统内存当中。 那么想要保证读改写共享变量的操作是原子的， 就必须保证 CPU1 读改写共享变量的时候，CPU2 不能操作缓存了该共享变量内存地址的缓存。<br>处理器使用总线锁就是来解决这个问题的。 所谓总线锁就是使用处理器提供的一个 LOCK＃ 信号，当一个处理器在总线上输出此信号时， 其他处理器的请求将被阻塞住, 那么该处理器可以独占使用共享内存。<br><img src="https://img-blog.csdn.net/20150929000908894" alt></p></li><li>用缓存锁保证原子性<br>频繁使用的内存会缓存在处理器的 L1，L2 和 L3 高速缓存里， 那么原子操作就可以直接在处理器内部缓存中进行， 并不需要声明总线锁， 在奔腾 6 和最近的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在 LOCK 操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言 LOCK＃ 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效，在上图中，当 CPU1 修改缓存行中的 i 时使用缓存锁定，那么 CPU2 就不能同时修改缓存了 i 的缓存行， 在 CPU1 更新后， CPU2 去主存拿最新值， 从而保证了数据的一致性。</li></ol><p>但是有两种情况下处理器不会使用缓存锁定。第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line），则处理器会调用总线锁定。第二种情况是：有些处理器不支持缓存锁定。对于 Inter486 和奔腾处理器,就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</p><p>以上两个机制我们可以通过 Inter 处理器提供了很多 LOCK 前缀的指令来实现。比如位测试和修改指令BTS，BTR，BTC，交换指令 XADD，CMPXCHG 和其他一些操作数和逻辑指令，比如 ADD（加），OR（或）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。</p><h1 id="AtomicInteger-源码如何实现原子性"><a href="#AtomicInteger-源码如何实现原子性" class="headerlink" title="AtomicInteger 源码如何实现原子性"></a>AtomicInteger 源码如何实现原子性</h1><p>类声明：<br><code>public class AtomicInteger extends Number implements java.io.Serializable</code></p><p>继承了 Number， 这主要是提供方法将数值转化为 byte, double 等方便 Java 开发者使用；<br>实现了 Serializable， 为了网络传输等的序列化用， 编码时最好手动生成序列化 ID， 让 javac 编译器生成开销大， 而且可能造成意想不到的状况。</p><p>变量声明：<br><code>private volatile int value;</code></p><p>原始类型变量声明为 private 的， 这样不会发生外部修改问题（逃逸）， 如果是引用的话， 再把引用用 public 方法暴露出去那么还是会造成逃逸现象， 不过这里是原始类型， 不会出现这种情况；<br>volatile 关键字修饰， 使 value 变量的改变具有可见性， 底层实现是内存栅栏，保证每次取到的是最新值。</p><p>get 方法： </p><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final 类型方法， 不可继承， 进一步保证线程安全。</p><p>自减操作： </p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> getAndDecrement() &#123;  </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        <span class="keyword">int</span> current = get();  </span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">next</span> = current - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, <span class="keyword">next</span>))  </span><br><span class="line">            <span class="keyword">return</span> current;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 for 是一个死循环， 是采用忙等（也叫自旋）的方式不断地尝试（乐观锁）－1 操作， 直到成功才退出。<br>这里的核心是调用了 compareAndSet() 方法， 传入当前值和新值。  </p><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, valueOffset, expect, update)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 JNI 调用底层其他语言实现的方法， 利用操作系统提供的 CAS（只要当前值和原来不一致就重新取值直到成功） 来保证原子性。</p><h1 id="CAS-的缺点"><a href="#CAS-的缺点" class="headerlink" title="CAS 的缺点"></a>CAS 的缺点</h1><p>基本上 Java 的 concurrent 包都是建立在 CAS 的基础上的， 甚至还包括业界一个很出名的应用于高频交易的框架 Disruptor 也是利用 CAS 来保证原子性。 但是 CAS 还是有它的缺点：</p><ol><li>ABA问题。因为 CAS 需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。<br>从Java1.5开始JDK的atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。这个类的compareAndSet 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li><li>循环时间长开销大。自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。如果JVM能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation：内存顺序冲突一般是由伪/假共享引起，假共享是指多个 CPU 同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。</li><li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</li></ol><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p><a href="https://blog.csdn.net/wenniuwuren" target="_blank" rel="noopener">wenniuwuren</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK 里面提供的以 Atomic* 开头的类基本原理都是一致的， 都是借助了底层硬件级别的 Lock 来实现原子操作的。 本文以 AtomicInteger 为例进行讲述， 其他的类似。阅读本文前建议先阅读基础篇：&lt;a href=&quot;https://blog.xiaomo.info/2018/jdkSourceCodeReadMemoryActor/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java内存模型&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-线程池</title>
    <link href="https://xiaomo.info/2018/jdkSourceCodeReadThreadPool/"/>
    <id>https://xiaomo.info/2018/jdkSourceCodeReadThreadPool/</id>
    <published>2018-06-02T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>Executors 是 Executor、ExecutorService、ThreadFactory、Callable 类的工厂和工具方法。<br><a id="more"></a></p><h1 id="创建一个固定大小的线程池"><a href="#创建一个固定大小的线程池" class="headerlink" title="创建一个固定大小的线程池"></a>创建一个固定大小的线程池</h1><p>通过重用共享无界队列里的线程来减少线程创建的开销。当所有的线程都在执行任务，新增的任务将会在队列中等待，直到一个线程空闲。由于在执行前失败导致的线程中断，如果需要继续执行接下去的任务，新的线程会取代它执行。线程池中的线程会一直存在，除非明确地 shutdown 掉。</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0</span>L, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的是 ThreadPoolExecutor 类的对象，这个构造方法使用传入的参数和默认的线程工厂与拒绝执行的处理。<br>corePoolSize：线程池中的线程数量，除非设置了 allowCoreThreadTimeOut， 否则就算线程空闲还是在保存在线程池中<br>maximumPoolSize：线程池中允许存放最大的线程数量<br>keepAliveTime：当线程数大于 corePoolSize，如果 keepAliveTime 内空闲的线程未执行，线程将被终结<br>unit：keepAliveTime 的时间单位<br>workQueue：保存 execute() 提交的任务 </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,  </span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到固定大小线程池，corePoolSize 和 maximumPoolSize 传入的参数是一样的</p><h1 id="创建一个单个线程的线程池"><a href="#创建一个单个线程的线程池" class="headerlink" title="创建一个单个线程的线程池"></a>创建一个单个线程的线程池</h1><p>任务会被保证顺序执行，因为只有一个工作线程。不像 newFixedThreadPool(1)，这个不保证任务顺序执行。corePoolSize 和 maximumPoolSize 都是 1。</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span>  </span><br><span class="line">        (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0</span>L, TimeUnit.MILLISECONDS,<span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建一个可按需自动扩容的线程池-但是会优先重用线程池中空闲可用的线程"><a href="#创建一个可按需自动扩容的线程池-但是会优先重用线程池中空闲可用的线程" class="headerlink" title="创建一个可按需自动扩容的线程池,但是会优先重用线程池中空闲可用的线程"></a>创建一个可按需自动扩容的线程池,但是会优先重用线程池中空闲可用的线程</h1><p>这个类型的线程池将会大大提升执行许多短暂的异步任务的程序。如果线程池中线程都在使用，又有新任务到来，则新增一个线程到线程池。如果线程 60 秒内空闲，则将被终止移除线程池。corePoolSize 为 0，可知一旦线程 60s 空闲就会被移出线程池</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60</span>L, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建一个在一定延迟时间后调度命令的线程池，或者周期性执行的线程池。"><a href="#创建一个在一定延迟时间后调度命令的线程池，或者周期性执行的线程池。" class="headerlink" title="创建一个在一定延迟时间后调度命令的线程池，或者周期性执行的线程池。"></a>创建一个在一定延迟时间后调度命令的线程池，或者周期性执行的线程池。</h1><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="keyword">new</span><span class="type">ScheduledThreadPool</span>(int corePoolSize) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ScheduledThreadPoolExecutor</span>(corePoolSize);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建完线程池，然后就该执行任务了"><a href="#创建完线程池，然后就该执行任务了" class="headerlink" title="创建完线程池，然后就该执行任务了"></a>创建完线程池，然后就该执行任务了</h1><p>看下内部类 DelegatedExecutorService 里的 execute 方法：可以看到任务执行策略（单线程串行、多线程并行）和任务的具体执行分离，是一个典型的命令模式。</p><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService e;  </span><br><span class="line">    DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123; e.execute(command); &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; e.shutdown(); &#125;  </span><br><span class="line">    <span class="keyword">public</span> List&lt;Runnable&gt; shutdownNow() &#123; <span class="function"><span class="keyword">return</span> e.<span class="title">shutdownNow</span><span class="params">()</span></span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123; <span class="function"><span class="keyword">return</span> e.<span class="title">isShutdown</span><span class="params">()</span></span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123; <span class="function"><span class="keyword">return</span> e.<span class="title">isTerminated</span><span class="params">()</span></span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> awaitTermination(<span class="keyword">long</span> timeout, TimeUnit unit)  </span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">awaitTermination</span><span class="params">(timeout, unit)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">submit</span><span class="params">(task)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">submit</span><span class="params">(task)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">submit</span><span class="params">(task, result)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks)  </span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">invokeAll</span><span class="params">(tasks)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks,  </span><br><span class="line">                                         <span class="keyword">long</span> timeout, TimeUnit unit)  </span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">invokeAll</span><span class="params">(tasks, timeout, unit)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T invokeAny(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks)  </span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">invokeAny</span><span class="params">(tasks)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T invokeAny(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks,  </span><br><span class="line">                           <span class="keyword">long</span> timeout, TimeUnit unit)  </span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">invokeAny</span><span class="params">(tasks, timeout, unit)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程池的时候，已经实例化了 ThreadPoolExecutor，所以上面 execute() 方法实际是调用 ThreadPoolExecutor 的 execute：给定的任务可能在未来的某个时刻执行。可能是新建一个线程执行，也可能是线程中原有的线程执行。如果任务不能执行，可能是这个 executor 已经被 shutdown 了，也可能是到达了线程池的执行阈值，任务被拒绝执行处理器处理中。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Runnable command</span>)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    <span class="keyword">int</span> c = ctl.<span class="keyword">get</span>();  </span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        c = ctl.<span class="keyword">get</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;  </span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.<span class="keyword">get</span>();  </span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; <span class="keyword">remove</span>(command))  </span><br><span class="line">            reject(command);  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)  </span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))  </span><br><span class="line">        reject(command);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这，其实发现线程池的核心实现就是在 ThreadPoolExecutor 里面，所以先介绍下 ThreadPoolExecutor 类的作用： </p><p><img src="https://image.xiaomo.info/blog/executor.png" alt></p><p>上图可以看出 ThreadPoolExecutor 类的层次结构中的位置，是对抽象方法和接口的完整实现，即核心代码在这个类里。</p><p>一个 ExecutorService 执行每个任务可能用到线程池中的一个或多个线程，线程池由 Executors 工厂创建。<br>线程池解决了两个不同的问题：</p><ol><li>执行大量异步的任务时，线程池减少线程的创建来减少开销，提升性能</li><li>提供了对资源的管理，包括当执行一系列任务时，线程的消耗。每个 ThreadPoolExecutor 也存储有些基本数据，诸如完成的任务数量</li></ol><p>想要在更广阔的背景下使用的话，这个类提供了许多可调整的参数和扩展的 hook。不管怎么样，还是推荐使用 Executors 来创建线程池比较方便。</p><p>这个主要的线程池控制状态 ctl，使用 AtomicInteger 存储两个概念上的字段 workerCount(线程池有效的线程数) 和 runState(线程池是 running、shuting down 等等状态) </p><p><code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</code></p><p>上述 execute() 方法有三个处理步骤：</p><ol><li>如果正在 running 的线程 (即 worker 线程) 小于 corePoolSize ( workerCountOf(c) &lt; corePoolSize )，尝试创建一个新线程并把传入的 command(任务) 作为它的第一个任务。调用 addWorker(command, true) 自动检查 runState 和 workCount，以便在不能增加线程的时候返回 false。添加成功直接 return，不能添加就要看下面的步骤</li><li>如果被成功放进队列（if (isRunning(c) &amp;&amp; workQueue.offer(command))  workQueue 是一个任务排队的阻塞队列），然后还需要二次检查线程池是否 shut down（上次检查后到这次检查前死亡）。所以我们重新检查状态，如果线程池停止的话，回滚进队操作，或者如果没有工作的线程开启一个新线程（addWorker(null, false);）</li><li>如果不能让任务进入阻塞队列，然后尝试新增一个线程。如果新增线程失败，可能是线程池 shut down 或者线程池饱和（达到 maxPoolSize），所以接下来抛弃这个任务。</li></ol><p>任务（Task）被包装在一个叫做 Worker 的内部类，Worker 继承 AQS 来实现任务增加/删除的同步控制，使用 HashSet 来保存 Worker 线程。如果 worker 线程大于 corePoolSize，则不创建 worker 线程，而是放入一个 BlockingQueue 排队。如果有界队列的 BlockingQueue 满了，则尝试增加线程到线程池，但是线程总数要小于 maxPollSize。</p><p>addWorker() 方法：检查线程池当前状态和线程数量的边界条件看是否可以增加 worker 线程。如果可以，工作线程计数响应调整，并且，如果可能的话，新的 worker 线程被创建，启动，跑它的第一个 task。如果线程池 stop 或者要被 shut down，此方法返回 false。如果线程工厂（thread factory）创建线程失败，此方法也会返回 false。如果线程创建失败，不管是 thread factory 返回 null，或者 exception（通常是 OOM），都会被回滚。</p><p>参数<br>firstTask： 新线程应该运行的第一个任务。如果 worker 线程小于 corePoolSize，worker 和初始化的第一次任务一起创建绕过排队这一过程，或者队列已满。初始化空闲线程通常是通过 prestartCoreThread 或者替换已经死亡的 worker 线程。<br>core：如果 true，则使用 corePoolSize 作为边界，否则使用 maximumPoolSize 作为边界。（这里使用 Boolean 而不是传入实际值，是因为传入值可能会在传入过程被改变，在方法中直接读取值更精确）。  </p><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">boolean</span> addWorker(Runnable firstTask, <span class="built_in">boolean</span> core) &#123;  </span><br><span class="line">    retry:  </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        <span class="built_in">int</span> c = ctl.<span class="built_in">get</span>();  </span><br><span class="line">        <span class="built_in">int</span> rs = runStateOf(c);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.  </span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;  </span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;  </span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;  </span><br><span class="line">               ! workQueue.isEmpty()))  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="built_in">int</span> wc = workerCountOf(c);  </span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||  </span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))  </span><br><span class="line">                <span class="keyword">break</span> retry;  </span><br><span class="line">            c = ctl.<span class="built_in">get</span>();  <span class="comment">// Re-read ctl  </span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)  </span><br><span class="line">                <span class="keyword">continue</span> retry;  </span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">boolean</span> workerStarted = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="built_in">boolean</span> workerAdded = <span class="keyword">false</span>;  </span><br><span class="line">    Worker w = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;  </span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);  </span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;  </span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            mainLock.lock();  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// Recheck while holding lock.  </span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if  </span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.  </span></span><br><span class="line">                <span class="built_in">int</span> c = ctl.<span class="built_in">get</span>();  </span><br><span class="line">                <span class="built_in">int</span> rs = runStateOf(c);  </span><br><span class="line">  </span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||  </span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable  </span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();  </span><br><span class="line">                    workers.<span class="built_in">add</span>(w);  </span><br><span class="line">                    <span class="built_in">int</span> s = workers.<span class="built_in">size</span>();  </span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)  </span><br><span class="line">                        largestPoolSize = s;  </span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                mainLock.unlock();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;  </span><br><span class="line">                t.start();  </span><br><span class="line">                workerStarted = <span class="keyword">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)  </span><br><span class="line">            addWorkerFailed(w);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> workerStarted;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p><a href="https://blog.csdn.net/wenniuwuren" target="_blank" rel="noopener">wenniuwuren</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Executors 是 Executor、ExecutorService、ThreadFactory、Callable 类的工厂和工具方法。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-Integer</title>
    <link href="https://xiaomo.info/2018/jdkSourceCodeReadInteger/"/>
    <id>https://xiaomo.info/2018/jdkSourceCodeReadInteger/</id>
    <published>2018-06-02T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>对于 Integer 这个 Java 程序员几乎天天使用的类,使用上却可以看出普通程序员和优秀程序员区别。<br><a id="more"></a></p><h1 id="深入代码"><a href="#深入代码" class="headerlink" title="深入代码"></a>深入代码</h1><p>在创建数字 1 的对象时， 大多数人会使用 new Integer(1)， 而使用 Integer.valueOf(1) 可以使用系统缓存，既减少可能的内存占用，也省去了频繁创建对象的开销。<br>系统默认只缓存 -128～127 之间的整数。下面我们看一下 Integer.valueOf(int) 方法的代码： </p><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;  </span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)  </span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到核心 <code>IntegerCache.cache[i + (-IntegerCache.low)]</code>， 观察<code>IntegerCache</code>类的源码实现：<br>为 －128 ～ 127 数值提供自动装箱的缓存服务。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        <span class="comment">// high value may be configured by property  </span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;  </span><br><span class="line">        String integerCacheHighPropValue =  </span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);  </span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);  </span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE  </span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        high = h;  </span><br><span class="line">  </span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];  </span><br><span class="line">        <span class="keyword">int</span> j = low;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)  </span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>static 静态代码块可知缓存的初始化是在第一次使用的时候。 通过 VM 参数-XX:AutoBoxCacheMax=<size> 可以配置缓存的最大值。 在 VM 初始化期间， 缓存最大值 high， 可能被保存在 sun.misc.VM class 的私有系统属性里。   </size></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  除非是 JDK 1.5 以前的环境， 如果系统不需要新对象， 则推荐使用 Long， Integer， Short， Character， Byte 的 valueOf() 方法提升性能。 </p><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p><a href="https://blog.csdn.net/wenniuwuren" target="_blank" rel="noopener">wenniuwuren</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于 Integer 这个 Java 程序员几乎天天使用的类,使用上却可以看出普通程序员和优秀程序员区别。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-内存模型</title>
    <link href="https://xiaomo.info/2018/jdkSourceCodeReadMemoryActor/"/>
    <id>https://xiaomo.info/2018/jdkSourceCodeReadMemoryActor/</id>
    <published>2018-06-02T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>为了让程序员忽略掉各种硬件和操作系统的内存访问差异， 也既无需关心不同架构上内存模型的差异， Java 在代码和硬件内存模型间又提供了一个 Java 内存模型。<br><a id="more"></a></p><h1 id="并发模型的分类"><a href="#并发模型的分类" class="headerlink" title="并发模型的分类"></a>并发模型的分类</h1><p>在并发编程中，需要处理两个关键问题：线程之间如何通信（线程之间以何种机制来交换信息， 有两种方式：共享内存和消息传递）及线程之间如何同步。</p><p>在共享内存的并发模型里（如 Java），线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态（主存）来隐式（对程序员透明）进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><p>虽然 Java 是共享内存并发模型， 对程序员透明， 但是不理解 Java 内存模型， 就会对内存可见性， 有序性等问题出现时找不到解决方法。</p><h1 id="Java-虚拟机运行时数据区"><a href="#Java-虚拟机运行时数据区" class="headerlink" title="Java 虚拟机运行时数据区"></a>Java 虚拟机运行时数据区</h1><p><img src="https://img-blog.csdn.net/20150927230534604" alt></p><p>虚拟机栈描述的是 Java 执行的内存模型： 每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、  操作数栈、 动态链接、 方法出口等信息。</p><p>Java 内存模型的主要目标是定义程序中各个变量的访问规则， 既在虚拟机中对变量的读写操作， 监视器的加锁和释放操作， 以及线程的启动和合并操作。</p><h1 id="原子性、-可见性和有序性"><a href="#原子性、-可见性和有序性" class="headerlink" title="原子性、 可见性和有序性"></a>原子性、 可见性和有序性</h1><p>Java 内存模型是围绕着在并发过程中如何处理原子性、 可见性和有序性来建立的。 </p><p> 原子性： 操作不可再分。 如在 Java 代码中使用 synchronized 和 ReentrantLock 来保障。<br> 可见性： A 线程操作， 对 B 线程可见， 既 A 变量赋值 1， B 线程能看见变量已经变为 1。 synchronized 、final、 volatile 和 ReentrantLock 都能提供。<br> 有序性： 在本线程内观察， 所有操作都是有序的（线程内表现为串行语义）； 如果在另一个线程中观察另一个线程， 所有操作都是无序的（指令重排序与工作内存与主内存同步延迟）。synchronized 、 volatile 和 ReentrantLock 都能提供有序性保证。</p><p> 从上述可以得出 synchronized 和 ReentrantLock 是万能的， 但是效率却有巨大的差别， ReentrantLock 会比 synchronized 好很多， ConcurrentHashMap 的源码实现中就利用了 ReentrantLock 分段锁来提升并发安全和效率。</p><h1 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h1><p>要保证 A 线程看到 B线程的操作结果（无论 A 和 B 是否在同一线程中执行）， 那么 A 和 B 之间必须满足 Happens-Before 关系。<br>Happens-Before 规则如下：</p><ol><li>序次序规则（Program Order Rule）：程序中 操作 A 在操作 B 之前， 那么在线程中 A 操作将在 B 操作之前进行。</li><li>管程锁定规则（Monitor Lock Rule）：一个 unlock 操作 happen—before 后面（时间上的先后顺序，下同）对同一个锁的 lock 操作。</li><li>volatile 变量规则：对一个 volatile 变量的写操作 happen—before 后面对该变量的读操作。</li><li>线程启动规则：Thread 对象的 start() 方法 happen—before 此线程的每一个动作。</li><li>线程终止规则：线程的所有操作都 happen—before 对此线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值等手段检测到线程已经终止执行。</li><li>线程中断规则：对线程 interrupt() 方法的调用 happen—before 发生于被中断线程的代码检测到中断时事件的发生。</li><li>终结器规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）happen—before 它的 finalize() 方法的开始。</li><li>传递性：如果操作A happen—before 操作 B，操作 B happen—before 操作 C，那么可以得出 A happen—before 操作 C。</li><li>如果两个操作间缺乏 Happens-Before 关系， 那么 JVM 可以对它们进行任意排序。</li></ol><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p><a href="https://blog.csdn.net/wenniuwuren" target="_blank" rel="noopener">wenniuwuren</a><br><a href="https://www.jianshu.com/p/2fdee831ed03" target="_blank" rel="noopener">Java内存溢出(OOM)异常完全指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了让程序员忽略掉各种硬件和操作系统的内存访问差异， 也既无需关心不同架构上内存模型的差异， Java 在代码和硬件内存模型间又提供了一个 Java 内存模型。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-Object</title>
    <link href="https://xiaomo.info/2018/jdkSourceCodeReadObject/"/>
    <id>https://xiaomo.info/2018/jdkSourceCodeReadObject/</id>
    <published>2018-06-01T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>Object类是类层次结构的根，是每一个类的父类。所有的对象（包括数组）都是实现了object类的方法。<br><a id="more"></a></p><p>Object结构<br><img src="https://image.xiaomo.info/blog/ObjectStructure.png" alt></p><p>这里有7个native方法：</p><ul><li>registerNatives()</li><li>getClass()</li><li>hashCode()</li><li>clone()</li><li>notify()</li><li>notifyAll()</li><li>wait(long)</li></ul><p>什么是native方法？简单的说，native表示该方法的实现java本身并没有完成，而是有c/c++来完成，放在.dll动态库文件中。这里我们不关注本地方法的具体，我们可以看看其注释和声明，知道这些方法是干什么的。</p><h3 id="1）registerNatives"><a href="#1）registerNatives" class="headerlink" title="1）registerNatives()"></a>1）<code>registerNatives()</code></h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法源码中并没有任何注释说明，而且在静态块中调用了方法。首先明确在类初始化的时候，这个方法被调用执行了。<br>至于该方法的做用，请看native方法的c代码实现：这里是相关的C代码（来自OpenJDK6）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line"></span><br><span class="line">　　&#123;“hashCode”, “()I”, (<span class="keyword">void</span> *)&amp;JVM_IHashCode&#125;,</span><br><span class="line"></span><br><span class="line">　　&#123;“wait”, “(J)V”, (<span class="keyword">void</span> *)&amp;JVM_MonitorWait&#125;,</span><br><span class="line"></span><br><span class="line">　　&#123;“notify”, “()V”, (<span class="keyword">void</span> *)&amp;JVM_MonitorNotify&#125;,</span><br><span class="line"></span><br><span class="line">　　&#123;“notifyAll”, “()V”, (<span class="keyword">void</span> *)&amp;JVM_MonitorNotifyAll&#125;,</span><br><span class="line"></span><br><span class="line">　　&#123;“clone”, “()Ljava/lang/Object;”, (<span class="keyword">void</span> *)&amp;JVM_Clone&#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"></span><br><span class="line">Java_java_lang_Object_registerNatives(JNIEnv *env, jclass cls)</span><br><span class="line">&#123;</span><br><span class="line">　　(*env)-&gt;RegisterNatives(env, cls,methods, <span class="keyword">sizeof</span>(methods)/<span class="keyword">sizeof</span>(methods[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细的说：通常情况下，为了使JVM发现您的本机功能，他们被一定的方式命名。例如，对于java.lang.Object.registerNatives，对应的C函数命名为Java_java_lang_Object_registerNatives。通过使用registerNatives（或者更确切地说，JNI函数RegisterNatives），您可以命名任何你想要你的C函数。(来自：<a href="https://www.linuxidc.com/Linux/2015-06/118676.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2015-06/118676.htm</a>)<br>简单的说：就是对几个本地方法进行注册(也就是初始化java方法映射到C的方法)。<br>细心的读者可能发现这里为什么没有getClass()方法的注册？因为它不需要被注册，它有一个Java_java_lang_Object_getClass的“标准”名称。</p><h3 id="（2）getClass"><a href="#（2）getClass" class="headerlink" title="（2）getClass()"></a>（2）getClass()</h3><p><code>public final native Class&lt;?&gt; getClass();</code></p><p>返回Object的运行时class对象，返回的对象是被静态同步方法锁定的对象（这意味着，该类的所有对象中，同时只有一个对象可以获得锁）。而且实际上返回的class对象是多态的，可以是调用者的子类（注释中Number的例子解释了这一内容）。</p><h3 id="（3）hashCode"><a href="#（3）hashCode" class="headerlink" title="（3）hashCode()"></a>（3）hashCode()</h3><p><code>public native int hashCode();</code></p><p>hashCode()也是一个native方法，该方法返回调用对象的hash码。hashCode必须满足以下协议：</p><ul><li>在一个Java应用中，对同一个对象多次调用hashCode()方法，必须返回相同的值。在对象被修改时，不提供equals方法的比较信息。（我的理解：不可以将hashCode值作为equals方法相等的充要条件，同一对象hashCode值肯定相等，不同对象hashCode值不一定不相等）</li><li>如果两个对象通过equals方法相等，那么两个对象的hashCode返回值必须要相等。</li><li>如果两个对象通过equals方法不相等，两个对象的hashCode返回值不一定不相等。但是程序员应该知道，不相等的对象若返回不想等的hash值，有助于提高hash表的性能。</li></ul><h3 id="（4）equals-Object-obj"><a href="#（4）equals-Object-obj" class="headerlink" title="（4）equals(Object obj)"></a>（4）equals(Object obj)</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>判断两个对象是不是相等。该方法遵循如下性质：</p><ul><li>自反性：对于任意非空引用x，则x.equals(x)返回true。</li><li>对称性：对于任意非空引用x、y，若x.equals(y)返回true，则y.equals(x)返回true。</li><li>传递性：对于任意非空引用x、y、z，若x.equals(y)返回true且y.equals(z)返回true，则x.equals(z)返回true。</li><li>对于任何非空引用值x和y，多次调用x.equals（y）始终返回true或者始终返回false，没有提供任何信息进行相等比较的对象被修改。</li><li>对于任意非空引用x，则x.equals(null)返回false。</li><li>重写equals方法必须重写hashCode方法来保证对任意两个对象equals返回值true时，他们的hashCode返回值必须相等。</li></ul><p>请注意源码中的实现是“==”号，必要时请重写该方法！</p><h3 id="（5）clone"><a href="#（5）clone" class="headerlink" title="（5）clone()"></a>（5）clone()</h3><p><code>protected native Object clone() throws CloneNotSupportedException;</code></p><p>创建和返回一个对象的复制。注意以下几点：</p><p>x.clone() != x  是true</p><p>一个对象可以被克隆的前提是该对象代表的类实现了Cloneable接口，否者会抛出一个CloneNotSupportedException异常。</p><p>调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。<br>克隆是浅复制。（详情：<a href="http://www.importnew.com/22035.html" target="_blank" rel="noopener">http://www.importnew.com/22035.html</a>）</p><h3 id="（6）toString"><a href="#（6）toString" class="headerlink" title="（6）toString()"></a>（6）toString()</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">String</span> toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + <span class="built_in">Integer</span>.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>返回一个表示该对象的字符串，默认实现是：类名@Integer.toHexString(hashCode())</p><p>建议子类重写该方法。</p><h3 id="（6）notify-、notifyAll-、wait-、wait-long-、wait-long-int"><a href="#（6）notify-、notifyAll-、wait-、wait-long-、wait-long-int" class="headerlink" title="（6）notify()、notifyAll()、wait()、wait(long)、wait(long,int)"></a>（6）notify()、notifyAll()、wait()、wait(long)、wait(long,int)</h3><p>这几个方法是多线程编程里面常用的方法，这里不多解释。</p><h3 id="（7）finalize"><a href="#（7）finalize" class="headerlink" title="（7）finalize()"></a>（7）finalize()</h3><p><code>protected void finalize() throws Throwable { }</code></p><p>这是一个被垃圾收集器调用的方法，当一个对象没有被其他引用指向时，垃圾回收器会清理该对象，在回收该对象之前会调用finalize方法。子类一般会重写该方法做一些系统资源清理工作。一个对象只会被调用一次finalize方法。如果finalize方法抛出异常，这个对象的终结将会停止。</p><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p><a href="https://blog.csdn.net/wenniuwuren" target="_blank" rel="noopener">wenniuwuren</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Object类是类层次结构的根，是每一个类的父类。所有的对象（包括数组）都是实现了object类的方法。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-NIO</title>
    <link href="https://xiaomo.info/2018/jdkSourceCodeReadNIO/"/>
    <id>https://xiaomo.info/2018/jdkSourceCodeReadNIO/</id>
    <published>2018-05-31T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>Java NIO和IO之间第一个区别是， IO是面向流的， NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节， 直至读取所有字节， 它们没有被缓存在任何地方。 JavaNIO的缓冲导向方法略有不同。 数据读取到一个它稍后处理的缓冲区， 需要时可在缓冲区中前后移动。 还需要检查是否该缓冲区中包含所有您需要处理的数据。 而且， 需确保当更多的数据读入缓冲区时， 不要覆盖缓冲区里尚未处理的数据。<br><a id="more"></a></p><p>另外， Java IO的各种流是阻塞的， 而Java NIO是非阻塞的。 IO是当一个线程调用read() 或write()时， 该线程被阻塞， 直到有一些数据被读取， 或数据完全写入。 该线程在此期间不能再干任何事情了。 而Java NIO的非阻塞模式， 使一个线程从某通道发送请求读取数据， 但是它仅能得到目前可用的数据， 如果目前没有数据可用时， 就什么都不会获取。 而不是保持线程阻塞， 所以直至数据变的可以读取之前， 该线程可以继续做其他的事情。 非阻塞写也是如此。 一个线程请求写入一些数据到某通道， 但不需要等待它完全写入， 这个线程同时可以去做别的事情。 而且， Java IO: 一个典型的IO服务器设计- 一个连接通过一个线程处理， 而NIO可让您只使用一个单线程管理多个通道（ 网络连接或文件） ， 但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。</p><h1 id="java-NIO主要组成部分"><a href="#java-NIO主要组成部分" class="headerlink" title="java NIO主要组成部分"></a>java NIO主要组成部分</h1><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><p>虽然Java NIO 中除此之外还有很多类和组件， 但在我看来， Channel， Buffer 和 Selector 构成了核心的API。 其它组件， 如Pipe和FileLock， 只不过是与三个核心组件共同使用的工具类。</p><p>Java NIO的通道类似流， 但又有些不同：</p><ul><li>既可以从通道中读取数据， 又可以写数据到通道。 但流的读写通常是单向的。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer， 或者总是要从一个Buffer中写入。</li></ul><h1 id="Channel-和-Buffer"><a href="#Channel-和-Buffer" class="headerlink" title="Channel 和 Buffer"></a>Channel 和 Buffer</h1><p>基本上， 所有的 IO 在NIO 中都从一个Channel 开始。 Channel 有点象流。 数据可以从Channel读到Buffer中， 也可以从Buffer 写到Channel中。</p><p>Channel和Buffer有好几种类型。 下面是JAVA NIO中的一些主要Channel的实现：</p><ul><li>FileChannel,从文件中读写数据。</li><li>DatagramChannel，能通过UDP读写网络中的数据</li><li>SocketChannel,能通过TCP读写网络中的数据</li><li>ServerSocketChannel,以监听新进来的TCP连接， 像Web服务器那样。 对每一个新进来的连接都会创建一个SocketChannel。<br>正如你所看到的， 这些通道涵盖了UDP 和 TCP 网络IO， 以及文件IO。</li></ul><p>基本的Channel示例</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">RandomAccessFile aFile = new RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>)<span class="comment">;</span></span><br><span class="line">FileChannel inChannel = aFile.getChannel()<span class="comment">;</span></span><br><span class="line"><span class="keyword">ByteBuffer </span><span class="keyword">buf </span>= <span class="keyword">ByteBuffer.allocate(48);</span></span><br><span class="line"><span class="keyword">int </span><span class="keyword">bytesRead </span>= inChannel.read(<span class="keyword">buf);</span></span><br><span class="line"><span class="keyword">while </span>(<span class="keyword">bytesRead </span>!= -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Read "</span> + <span class="keyword">bytesRead);</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">buf.flip();</span></span><br><span class="line"><span class="keyword"> </span>   while (<span class="keyword">buf.hasRemaining()) </span>&#123;</span><br><span class="line">        System.out.print((char) <span class="keyword">buf.get());</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    <span class="keyword">buf.clear();</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">bytesRead </span>= inChannel.read(<span class="keyword">buf);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword">aFile.close();</span></span><br></pre></td></tr></table></figure><p>注意 buf.flip() 的调用， 首先读取数据到Buffer， 然后反转Buffer,接着再从Buffer中读取数据。</p><p>Java NIO中的Buffer用于和NIO通道进行交互。 如你所知， 数据是从通道读入缓冲区， 从缓冲区写入到通道中的。缓冲区本质上是一块可以写入数据， 然后可以从中读取数据的内存。 这块内存被包装成NIOBuffer对象， 并提供了一组方法， 用来方便的访问该块内存。以下是Java NIO里关键的Buffer实现：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><p>这些Buffer覆盖了你能通过IO发送的基本数据类型： byte, short, int, long, float, double 和char。Java NIO 还有个 MappedByteBuffer， 用于表示内存映射文件。</p><p>当向buffer写入数据时， buffer会记录下写了多少数据。 一旦要读取数据， 需要通过flip()方法将Buffer从写模式切换到读模式。 在读模式下， 可以读取之前写入到buffer的所有数据。一旦读完了所有的数据， 就需要清空缓冲区， 让它可以再次被写入。 有两种方式能清空缓冲区： 调用clear()或compact()方法。 clear()方法会清空整个缓冲区。 compact()方法只会清除已经读过的数据。 任何未读的数据都被移到缓冲区的起始处， 新写入的数据将放到缓冲区未读数据的后面。</p><h1 id="Buffer的capacity-position和limit"><a href="#Buffer的capacity-position和limit" class="headerlink" title="Buffer的capacity,position和limit"></a>Buffer的capacity,position和limit</h1><ul><li>position<br>当你写数据到Buffer中时， position表示当前的位置。 初始的position值为0.当一个byte、 long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。 position最大可为capacity – 1.当读取数据时， 也是从某个特定位置读。 当将Buffer从写模式切换到读模式， position会被重置为0. 当从Buffer的position处读取数据时， position向前移动到下一个可读的位置。</li><li>limit<br>在写模式下， Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下， limit等于Buffer的capacity。当切换Buffer到读模式时， limit表示你最多能读到多少数据。 因此， 当切换Buffer到读模式时， limit会被设置成写模式下的position值。 换句话说， 你能读到之前写入的所有数据（ limit被设置成已写数据的数量， 这个值在写模式下就是position）</li></ul><h3 id="向Buffer中写数据"><a href="#向Buffer中写数据" class="headerlink" title="向Buffer中写数据"></a>向Buffer中写数据</h3><p>写数据到Buffer有两种方式：<br>从Channel写到Buffer。<br>通过Buffer的put()方法写到Buffer里。</p><h3 id="从Buffer中读取数据"><a href="#从Buffer中读取数据" class="headerlink" title="从Buffer中读取数据"></a>从Buffer中读取数据</h3><p>从Buffer中读取数据有两种方式：<br>从Buffer读取数据到Channel。<br>使用get()方法从Buffer中读取数据。</p><h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><p>Selector（ 选择器） 是Java NIO中能够检测一到多个NIO通道， 并能够知晓通道是否为诸如读写事件做好准备的组件。 这样， 一个单独的线程可以管理多个channel， 从而管理多个网络连接。Selector允许单线程处理多个 Channel。 如果你的应用打开了多个连接（ 通道） ， 但每个连接的流量都很低， 使用Selector就会很方便。 例如， 在一个聊天服务器中</p><h1 id="为什么使用Selector"><a href="#为什么使用Selector" class="headerlink" title="为什么使用Selector?"></a>为什么使用Selector?</h1><p>仅用单个线程来处理多个Channels的好处是， 只需要更少的线程来处理通道。 事实上， 可以只用一个线程处理所有的通道。 对于操作系统来说， 线程之间上下文切换的开销很大， 而且每个线程都要占用系统的一些资源（ 如内存） 。 因此， 使用的线程越少越好。</p><h3 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h3><p>通过调用Selector.open()方法创建一个Selector， 如下：<br><code>Selector selector = Selector.open();</code></p><p><img src="https://image.xiaomo.info/blog/selector.png" alt><br>要使用Selector， 得向Selector注册Channel， 然后调用它的select()方法。 这个方法会一直阻塞到某个注册的通道有事件就绪。 一旦这个方法返回， 线程就可以处理这些事件， 事件的例子有如新连接进来， 数据接收等。与Selector一起使用时， Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用， 因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">SelectionKey key = channel.<span class="keyword">register</span>(selector, Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p> 注意register()方法的第二个参数。 这是一个“interest集合”， 意思是在通过Selector监听Channel时对什么事件感兴趣。 可以监听四种不同类型的事件</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>如果你对不止一种事件感兴趣， 那么可以用“位或”操作符将常量连接起来， 如下:<br><code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</code></p><h1 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h1><p>Java NIO开始支持scatter/gather， scatter/gather可以从Channel中读入和读取数据。分散（ scatter） 从Channel中读取是指在读操作时将读取的数据写入多个buffer中。 因此，Channel将从Channel中读取的数据“分散（ scatter） ”到多个Buffer中。聚集（ gather） 写入Channel是指在写操作时将多个buffer的数据写入同一个Channel， 因此，Channel 将多个Buffer中的数据“聚集（ gather） ”后发送到Channel。scatter / gather经常用于需要将传输的数据分开处理的场合， 例如传输一个由消息头和消息体组成的消息， 你可能会将消息体和消息头分散到不同的buffer中， 这样你可以方便的处理消息头和消息体</p><h1 id="Scattering-Reads"><a href="#Scattering-Reads" class="headerlink" title="Scattering Reads"></a>Scattering Reads</h1><p> Scattering Reads是指数据从一个channel读取到多个buffer中。</p> <figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ByteBuffer </span>header = <span class="keyword">ByteBuffer.allocate(128);</span></span><br><span class="line"><span class="keyword">ByteBuffer </span><span class="keyword">body </span>= <span class="keyword">ByteBuffer.allocate(1024);</span></span><br><span class="line"><span class="keyword">ByteBuffer[] </span><span class="keyword">bufferArray </span>= &#123; header, <span class="keyword">body </span>&#125;<span class="comment">;</span></span><br><span class="line">channel.read(<span class="keyword">bufferArray);</span></span><br></pre></td></tr></table></figure><p> read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer， 当一个buffer被写满后， channel紧接着向另一个buffer中写。Scattering Reads在移动下一个buffer前， 必须填满当前的buffer， 这也意味着它不适用于动态消息(译者注： 消息大小不固定)。 换句话说， 如果存在消息头和消息体， 消息头必须完成填充（ 例如 128byte） ， Scattering Reads才能正常工作</p><h1 id="Gathering-Writes"><a href="#Gathering-Writes" class="headerlink" title="Gathering Writes"></a>Gathering Writes</h1><p> Gathering Writes是指数据从多个buffer写入到同一个channel。</p> <figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ByteBuffer </span>header = <span class="keyword">ByteBuffer.allocate(128);</span></span><br><span class="line"><span class="keyword">ByteBuffer </span><span class="keyword">body </span>= <span class="keyword">ByteBuffer.allocate(1024);</span></span><br><span class="line"><span class="keyword">//write </span><span class="meta">data</span> into <span class="keyword">buffers</span></span><br><span class="line"><span class="keyword">ByteBuffer[] </span><span class="keyword">bufferArray </span>= &#123; header, <span class="keyword">body </span>&#125;<span class="comment">;</span></span><br><span class="line"><span class="symbol">channel.write</span>(<span class="keyword">bufferArray);</span></span><br></pre></td></tr></table></figure><p> buffers数组是write()方法的入参， write()方法会按照buffer在数组中的顺序， 将数据写入到channel， 注意只有position和limit之间的数据才会被写入。 因此， 如果一个buffer的容量为128byte， 但是仅仅包含58byte的数据,那么这58byte的数据将被写入到channel中。 因此 Scattering Reads相反， Gathering Writes能较好的处理动态消息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java NIO和IO之间第一个区别是， IO是面向流的， NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节， 直至读取所有字节， 它们没有被缓存在任何地方。 JavaNIO的缓冲导向方法略有不同。 数据读取到一个它稍后处理的缓冲区， 需要时可在缓冲区中前后移动。 还需要检查是否该缓冲区中包含所有您需要处理的数据。 而且， 需确保当更多的数据读入缓冲区时， 不要覆盖缓冲区里尚未处理的数据。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-throwable和Exception的区别</title>
    <link href="https://xiaomo.info/2018/throwableAndException/"/>
    <id>https://xiaomo.info/2018/throwableAndException/</id>
    <published>2018-05-29T00:00:00.000Z</published>
    <updated>2019-10-08T14:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>在写代码的时候Exception随手就来，但是提到Throwable总觉得又熟悉又陌生。<br><a id="more"></a></p><p>先上图为敬<br><img src="https://image.xiaomo.info/blog/throwable.jpg" alt></p><p>从上图可以看出,throwable是Exception的父类，它包含了系统级的Error和程序级的Exception,所以接触的少倒也不足为奇。</p><h1 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h1><p>异常的英文单词是exception，字面翻译就是“意外、例外”的意思，也就是非正常情况。事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用空的引用、数组下标越界、内存溢出错误等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果。因此，如何对运行期间出现的错误进行处理和补救呢？Java提供了异常机制来进行处理，通过异常机制来处理程序运行期间出现的错误。通过异常机制，我们可以更好地提升程序的健壮性。</p><h1 id="什么是错误"><a href="#什么是错误" class="headerlink" title="什么是错误"></a>什么是错误</h1><p>是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。通常，Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。<br>可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。<br>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><h1 id="应该catch什么"><a href="#应该catch什么" class="headerlink" title="应该catch什么"></a>应该catch什么</h1><p>其实只要是Throwable和其子类都是可以throw和catch的，那么如果在需要统一处理异常的地方，我们应该catch (Throwable th) 还是 catch (Exception)呢？<br>这两种处理的区别在于，catch throwable会把Error和其他继承Throwable的类捕捉到。而catch Exception只会捕捉Exception极其子类，捕捉的范围更小。先不考虑有其他的类继承了Throwable的情况下，第一种catch相当于比第二种catch多捕捉了把Error和其子类。<br>那么究竟Error是否需要捕捉呢？JDK中Error类的的注释（如下）里提到过，Error是一种严重的问题，应用程序不应该捕捉它。 </p><h1 id="Error可以catch吗？-可以catch了后做些其他处理吗？"><a href="#Error可以catch吗？-可以catch了后做些其他处理吗？" class="headerlink" title="Error可以catch吗？ 可以catch了后做些其他处理吗？"></a>Error可以catch吗？ 可以catch了后做些其他处理吗？</h1><p>Error是可以catch的，而且也可以向常规Exception一样被处理，而且就算不捕捉的话也只是导致当前线程挂掉，其他线程还是可以正常运行，如果有需要的话捕捉Error之后也可以做些其他处理。但是Error是一种系统内部的错误，这种错误不像Exception一样是可能是程序和业务上的错误是可以恢复的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写代码的时候Exception随手就来，但是提到Throwable总觉得又熟悉又陌生。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
</feed>
